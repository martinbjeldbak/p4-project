Package dk.aau.cs.d402f13.ScannerParser;

Helpers
  tab              = 9;
  cr               = 13;
  lf               = 10;
  decimal          = ['0' .. '9'];
  lowercase        = ['a' .. 'z'];
  uppercase        = ['A' .. 'Z'];
  unichar          = [0 .. 0xffff];
  quote            = '"';
  backslash        = '\';
  strchar          = [unichar - [quote + backslash]];
  keyword          = 'piece' | 'this' | 'width' | 'height'
                   | 'title' | 'players' | 'turnOrder' | 'board'
                   | 'grid' | 'setup' | 'wall' | 'name' | 'possibleDrops'
                   | 'possibleMoves' | 'winCondition' | 'tieCondition';
  shared_operator  = '*' | '+';
  normal_operator  = '-' | '!=' | '==' | '<=' | '>=';
  pattern_operator = '?' | '!';  
  pattern_not      = '!';
  pattern_or       = '|';
  pattern_keyword  = 'friend' | 'foe' | 'empty';
  direction        = 'n' | 's' | 'e' | 'w' | 'ne' | 'nw' | 'se' | 'sw';
  comma      = ',';
  star       = '*';
  qmark      = '?';
  plus       = '+';
  variable   = '$' (lowercase | uppercase)+;
  eql        = '=';
 
Tokens
  eol              = cr | lf | cr lf;
  blank            = ' ' | tab;
  decimal          = decimal;
  lowercase        = lowercase;
  uppercase        = uppercase;
  unichar          = unichar;
  strchar          = strchar;
  keyword          = keyword;
  shared_operator  = shared_operator;
  normal_operator  = normal_operator;
  pattern_operator = pattern_operator;
  pattern_or       = pattern_or;
  pattern_not      = pattern_not;
  pattern_keyword  = pattern_keyword;
  direction        = direction;

  define     = 'define';
  game       = 'game';
  not        = 'not';
  if         = 'if';
  then       = 'then';
  else       = 'else';
  let        = 'let';
  in         = 'in';
  l_bkt      = '[';
  r_bkt      = ']';
  l_brc      = '{';
  r_brc      = '}';
  l_par      = '(';
  r_par      = ')';
  eql        = eql;
  comma      = comma;
  arrow      = '=>';
  slash      = '/';
  pound      = '#';
  emark      = '!';
  this       = 'this';

  star_qmark_plus = star | qmark | plus;
  
  integer    = decimal+;
  coordinate = uppercase+ decimal+;
  string     = '"' (strchar | '\' unichar)* '"';

  /* identifiers */
  function   = lowercase (lowercase | uppercase)+;
  identifier = uppercase (lowercase | uppercase)*;
  variable   = variable;
  
  operator = normal_operator | shared_operator;
  
Ignored Tokens
  blank, eol;
  
Productions
  /* program structure*/
  program            = function_def* game_decl;
  function_def       = define function l_bkt variable* r_bkt expression;
  game_decl          = game decl_struct;
  decl_struct        = l_brc decl+ r_brc;
  decl               = {keystruc} keyword structure
                     | {idstruc} identifier structure;                  
  structure          = {declstruc} decl_struct
                     | {expr} expression;
  
  /* expressions */
  expression    = {func} function_call
                | {elopexp} element operator expression
                | {assign} assignment
                | {if} if_expr
                | {lambda} lambda_expr
                | {el} element
                | {not} not expression;
  element       = {expr} l_par expression r_par
                | {var} variable
                | {list} list
                | {pat} [left]:slash pattern [right]:slash
                | {key} keyword
                | {dir} direction
                | {cor} coordinate
                | {int} integer
                | {str} string
                | {id} identifier
                | {func} function;
  function_call = function list;
  var_expr      = comma variable eql expression;
  assignment    = let variable eql [left]:expression var_expr* in [right]:expression;
  if_expr       = if [left]:expression then expression else [right]:expression;
  lambda_expr   = pound l_bkt variable* r_bkt arrow expression;
  list          = l_bkt element* r_bkt;
  
  /* patterns */
  pattern       = pattern_expr+;
  pattern_expr  = {patval} pattern_val star_qmark_plus
                | {patvalexpr} pattern_val pattern_or pattern_expr;
  pattern_val   = {dir} direction
                | {var} variable
                | {patcheck} pattern_check
                | {emarkpatcheck} emark pattern_check
                | {lpatexprr} l_par pattern integer?;
  pattern_check = {patkey} pattern_keyword
                | {this} this
                | {id} identifier;
  
