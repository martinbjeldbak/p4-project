package dk.aau.cs.d402f13.evaluation;

import java.util.HashSet;
import dk.aau.cs.d402f13.utilities.SimpleDir;
import dk.aau.cs.d402f13.utilities.errors.StandardError;
import dk.aau.cs.d402f13.utilities.gameapi.Game;
import dk.aau.cs.d402f13.utilities.gameapi.Piece;
import dk.aau.cs.d402f13.utilities.gameapi.Player;
import dk.aau.cs.d402f13.utilities.gameapi.Square;
import dk.aau.cs.d402f13.values.*;

public class GridBoardPatternEvaluator {
  
  private Game game;
  private boolean  squareVisited[][];

  public boolean doesPatternMatch(Game game, PatternValue pv, DirValue squarePos) throws StandardError{
    this.game = game;
    this.squareVisited = new boolean[game.getBoard().getWidth()][];
    for (int i = 0; i < game.getBoard().getWidth(); i++)
    	this.squareVisited[i] = new boolean[game.getBoard().getHeight()];
    HashSet<SimpleDir> workingSet = new HashSet<SimpleDir>();
    workingSet.add(new SimpleDir(2,2)); //start at 2,2
    workingSet = evaluate(pv, workingSet);
    if (workingSet.size() == 0){
    	return false;	
    }
    else{
    	return true;
    }
  }
  
  private Player currentPlayer() throws StandardError{
    return this.game.getCurrentPlayer();
  }
  
  private HashSet<SimpleDir> evaluate(Value v, HashSet<SimpleDir> workingSet) throws StandardError{
    if (v instanceof PatternOrValue)
      return evaluatePatternOrValue((PatternOrValue)v, workingSet);
    else if (v instanceof DirValue)
      return addDirValue((DirValue)v, workingSet); //adds direction to all SimpleDir in current set
    else if (v instanceof PatternKeyValue)
      return addPatternKeyValue((PatternKeyValue)v, workingSet, false); //adds dirValue to all dirs in current set
    else if (v instanceof PatternNotValue)
      return addPatternKeyValue( (PatternKeyValue)((PatternNotValue)v).getValue(), workingSet, true ); //PatternNotValue contains a PatternKeyValue as its value
    else if (v instanceof PatternPlusValue)
      return evaluatePatternPlusValue((PatternPlusValue)v, workingSet);
    else if (v instanceof PatternMultValue)
      return evaluatePatternMultValue((PatternMultValue)v, workingSet);
    else if (v instanceof PatternOptValue)
        return evaluatePatternOptValue((PatternOptValue)v, workingSet);
    else if (v instanceof PatternValue)
      return evaluatePatternValue((PatternValue)v, workingSet);
    else
      throw new StandardError("Not intended");
  }
  private HashSet<SimpleDir> evaluatePatternOptValue(PatternOptValue pov, HashSet<SimpleDir> workingSet) throws StandardError{
	  //PatternOptValue contains only 1 value
	  
	  //evaluate the value once on a clone, so it does not effect the set containing no evaluation 
	  HashSet<SimpleDir> evluatedOnce = evaluatePatternValue(new PatternValue(pov.getValue()), makeClone(workingSet));
	  //return the set obtained after evaluating once united with the original set.
	  unionOnFirst(workingSet, evluatedOnce);
	  return workingSet;
  }
  private HashSet<SimpleDir> evaluatePatternPlusValue(PatternPlusValue pmv, HashSet<SimpleDir> workingSet) throws StandardError{
	  //PatternPlusValue contains only 1 value
	  
	  //evaluate the value once
	  workingSet = evaluatePatternValue(new PatternValue(pmv.getValue()), workingSet);
	  //evaluate the value 0 to many times
	  return evaluatePatternMultValue(new PatternMultValue(pmv.getValue()), workingSet);
  }
  private HashSet<SimpleDir> evaluatePatternMultValue(PatternMultValue pmv, HashSet<SimpleDir> workingSet) throws StandardError{
    int oldCount;

    HashSet<SimpleDir> applyMultOn = workingSet;
    do
    {
      //oldCount lets us know if any new things are added during the kleenee-star operation
      //if no new things are added, there is no reason to keep during the operation
      oldCount = workingSet.size(); 
      
      //Ensure that kleenee-star is not applied to all sequences but only those generated by last run
      applyMultOn = makeClone(applyMultOn);
      applyMultOn = evaluate(pmv.getValue(), applyMultOn);
      
      //add the newly found sequences to the original set
      unionOnFirst(workingSet, applyMultOn);
    }
    //stop is something new has not been added or if anything has gone out of board
    while (workingSet.size() > oldCount);
    return workingSet;
  }
  
  private HashSet<SimpleDir> evaluatePatternOrValue(PatternOrValue v, HashSet<SimpleDir> workingSet) throws StandardError {
    HashSet<SimpleDir> clone = makeClone(workingSet); //make sure the side effects from evaluating the left side is not visible when evaluating the right side of or
    HashSet<SimpleDir> leftOr = evaluate(v.getLeft(), workingSet);
    HashSet<SimpleDir> rightOr = evaluate(v.getRight(), clone);
    unionOnFirst(leftOr, rightOr);
    return leftOr;
  }
 
  private HashSet<SimpleDir> evaluatePatternValue(PatternValue pv, HashSet<SimpleDir> workingSet) throws StandardError{
    for (Value v : pv.getValues()){
      workingSet = evaluate(v, workingSet);
    }
    return workingSet;
  }
  private HashSet<SimpleDir> makeClone(HashSet<SimpleDir> set) throws StandardError{
    HashSet<SimpleDir> result = new HashSet<SimpleDir>();
    for (SimpleDir ds : set)
      result.add(new SimpleDir(ds.x, ds.y));
    return result;
  }
  
  private void unionOnFirst (HashSet<SimpleDir> first, HashSet<SimpleDir> second){
    //adds all elements in the second second set to the first set  
    //setLeft = {n, w, ee}
    //setRight = {e, s, w}
    //modifies setRight to {n, w, ee, e, s}
    for (SimpleDir ds : second)
      first.add(ds);
  }
  
  private HashSet<SimpleDir> addDirValue(DirValue dirVal, HashSet<SimpleDir> workingSet) throws StandardError{
    HashSet<SimpleDir> newSet = new HashSet<SimpleDir>(); 
    for (SimpleDir ds : workingSet){
    	ds.x += dirVal.getX();
    	ds.y += dirVal.getY();
		if (!outOfBoard(ds.x, ds.y)){ 
			//if (!this.squareVisited[ds.x-1][ds.y-1]){ //board starts at 1, array at 0
				newSet.add(ds);
			//	this.squareVisited[ds.x-1][ds.y-1] = true;
			//}
		}
	}
   return newSet;
  }
  
  private boolean outOfBoard(int x, int y) throws StandardError{
    //if (val.x < 1 || val.y < 1 || val.x > this.game.getBoard().getWidth() || val.y > this.game.getBoard().getHeight())
    if (x < 1 || y < 1 || x > 5 || y > 5){
      return true;
    }
    return false;
  }
  
  private HashSet<SimpleDir> addPatternKeyValue(PatternKeyValue keyVal, HashSet<SimpleDir> workingSet, boolean negate) throws StandardError{
    
	  HashSet<SimpleDir> newSet = new HashSet<SimpleDir>();
    for (SimpleDir ds : workingSet){
    	
        if (keyIsOk(keyVal, ds) != negate){
        	newSet.add(ds);
        	System.out.println("Found " + (negate? "not " : "") + keyVal + " at (" +ds.x+","+ds.y+")");
        }
        else
        	System.out.println("Dit not find " + (negate? "not " : "") + keyVal + " at (" +ds.x+","+ds.y+")");
    }
    return newSet;
  }
  


  private boolean keyIsOk(PatternKeyValue pv, SimpleDir position) throws StandardError{
    Square foundSquare = this.game.getBoard().getSquareAt(position.x, position.y);
    switch (pv.toString()){
      case "friend":
        if (!friend(foundSquare))
          return false;
        break;
      case "foe":
        if (!foe(foundSquare))
          return false;
        break;
      case "empty":
        if (!empty(foundSquare))
          return false;
        break;
      default:
        throw new StandardError("Unrecognised pattern keyword: " + pv.toString());
    }
    return true;
  }
  
  private boolean friend(Square s) throws StandardError{
    for (Piece p : s.getPieces()){
      if (p.getOwner().equals(currentPlayer()))
        return true;
    }
    return false;
  }
  private boolean foe(Square s) throws StandardError{
    for (Piece p : s.getPieces()){
      if (!p.getOwner().equals(currentPlayer()))
        return true;
    }
    return false;
  }
  private boolean empty(Square s) throws StandardError{
    return s.getPieces().length == 0;
  }

}
