package dk.aau.cs.d402f13.evaluation;

import java.util.HashSet;
import java.util.Iterator;

import dk.aau.cs.d402f13.utilities.SimpleDir;
import dk.aau.cs.d402f13.utilities.errors.StandardError;
import dk.aau.cs.d402f13.utilities.gameapi.Game;
import dk.aau.cs.d402f13.utilities.gameapi.Piece;
import dk.aau.cs.d402f13.utilities.gameapi.Player;
import dk.aau.cs.d402f13.utilities.gameapi.Square;
import dk.aau.cs.d402f13.values.*;

public class GridBoardPatternEvaluator {
  
  private Game game;


  public boolean doesPatternMatch(Game game, PatternValue pv, DirValue squarePos) throws StandardError{
    this.game = game;
    HashSet<SimpleDir> workingSet = new HashSet<SimpleDir>();
    workingSet.add(new SimpleDir(2,2)); //start at 2,2
    evaluate(pv, workingSet);
    if (workingSet.size() == 0){
    	return false;	
    }
    else{
    	return true;
    }
  }
  
  private Player currentPlayer() throws StandardError{
    return this.game.getCurrentPlayer();
  }
  
  private void evaluate(Value v, HashSet<SimpleDir> workingSet) throws StandardError{
    if (v instanceof PatternOrValue)
      evaluatePatternOrValue((PatternOrValue)v, workingSet);
    else if (v instanceof DirValue)
      addDirValue((DirValue)v, workingSet); //adds direction to all SimpleDir in current set
    else if (v instanceof PatternKeyValue)
      addPatternKeyValue((PatternKeyValue)v, workingSet, false); //adds dirValue to all dirs in current set
    else if (v instanceof PatternNotValue)
      addPatternKeyValue( (PatternKeyValue)((PatternNotValue)v).getValue(), workingSet, true ); //PatternNotValue contains a PatternKeyValue as its value
    else if (v instanceof PatternPlusValue)
      evaluatePatternPlusValue((PatternPlusValue)v, workingSet);
    else if (v instanceof PatternMultValue)
      evaluatePatternMultValue((PatternMultValue)v, workingSet);
    else if (v instanceof PatternOptValue)
      evaluatePatternOptValue((PatternOptValue)v, workingSet);
    else if (v instanceof PatternValue)
      evaluatePatternValue((PatternValue)v, workingSet);
    else
      throw new StandardError("Not intended");
  }
  private HashSet<SimpleDir> evaluatePatternOptValue(PatternOptValue pov, HashSet<SimpleDir> workingSet) throws StandardError{
	  //PatternOptValue contains only 1 value
	  
	  //evaluate the value once on a clone, so it does not effect the set containing no evaluation 
	  HashSet<SimpleDir> evluatedOnce = evaluatePatternValue(new PatternValue(pov.getValue()), makeClone(workingSet));
	  //return the set obtained after evaluating once united with the original set.
	  unionOnFirst(workingSet, evluatedOnce);
	  return workingSet;
  }
  private HashSet<SimpleDir> evaluatePatternPlusValue(PatternPlusValue pmv, HashSet<SimpleDir> workingSet) throws StandardError{
	  //PatternPlusValue contains only 1 value
	  
	  //evaluate the value once
	  workingSet = evaluatePatternValue(new PatternValue(pmv.getValue()), workingSet);
	  //evaluate the value 0 to many times
	  return evaluatePatternMultValue(new PatternMultValue(pmv.getValue()), workingSet);
  }
  private HashSet<SimpleDir> evaluatePatternMultValue(PatternMultValue pmv, HashSet<SimpleDir> workingSet) throws StandardError{
 
    HashSet<SimpleDir> applyMultOn = workingSet;
    HashSet<SimpleDir> lastSet;
    do
    { 
      lastSet = makeClone(workingSet); 
      
      //Ensure that kleenee-star is not applied to all sequences but only those generated by last run
      applyMultOn = makeClone(applyMultOn); //fully cloned set and values
      evaluate(pmv.getValue(), applyMultOn);
      
      //add the newly found sequences to the original set
      unionOnFirst(workingSet, applyMultOn);
    }
    //stop is something new has not been added or if anything has gone out of board
    while (!setsAreEqual(workingSet, lastSet));
    return workingSet;
  }
  
  private boolean setsAreEqual(HashSet<SimpleDir> set1, HashSet<SimpleDir> set2){
    int hash1 = 0, hash2 = 0;
    for (SimpleDir sd : set1)
      hash1 ^= sd.x * 117 + sd.y;
    for (SimpleDir sd : set2)
      hash2 ^= sd.x * 117 + sd.y;
    if (hash1 != hash2)
      return false;
    for (SimpleDir sd : set1)
      if (!set2.contains(sd))
        return false;
    return true;
  }
  
  private void evaluatePatternOrValue(PatternOrValue v, HashSet<SimpleDir> workingSet) throws StandardError {
    HashSet<SimpleDir> clone = makeClone(workingSet); //make sure the side effects from evaluating the left side is not visible when evaluating the right side of or
    evaluate(v.getLeft(), workingSet);
    evaluate(v.getRight(), clone);
    unionOnFirst(workingSet, clone);
  }
 
  private HashSet<SimpleDir> evaluatePatternValue(PatternValue pv, HashSet<SimpleDir> workingSet) throws StandardError{
    for (Value v : pv.getValues()){
      evaluate(v, workingSet);
    }
    return workingSet;
  }
  private HashSet<SimpleDir> makeClone(HashSet<SimpleDir> set) throws StandardError{
    HashSet<SimpleDir> result = new HashSet<SimpleDir>();
    for (SimpleDir ds : set)
      result.add(new SimpleDir(ds.x, ds.y));
    return result;
  }
  
  private void unionOnFirst (HashSet<SimpleDir> first, HashSet<SimpleDir> second){
    //adds all elements in the second second set to the first set  
    //setLeft = {n, w, ee}
    //setRight = {e, s, w}
    //modifies setRight to {n, w, ee, e, s}
    for (SimpleDir ds : second)
      first.add(ds);
  }
  
  private void addDirValue(DirValue dirVal, HashSet<SimpleDir> workingSet) throws StandardError{
    Iterator<SimpleDir> it = workingSet.iterator();
    while (it.hasNext()){
      SimpleDir ds = it.next();
      if (outOfBoard(ds.x + dirVal.getX(), ds.y + dirVal.getY())){ 
		it.remove(); //removes the last returned element (ds)
      }
      else{
        ds.x += dirVal.getX();
        ds.y += dirVal.getY();
      }
	}
  }
  
  private boolean outOfBoard(int x, int y) throws StandardError{
    //if (val.x < 1 || val.y < 1 || val.x > this.game.getBoard().getWidth() || val.y > this.game.getBoard().getHeight())
    if (x < 1 || y < 1 || x > 5 || y > 5){
      return true;
    }
    return false;
  }
  
  private HashSet<SimpleDir> addPatternKeyValue(PatternKeyValue keyVal, HashSet<SimpleDir> workingSet, boolean negate) throws StandardError{
    
	  HashSet<SimpleDir> newSet = new HashSet<SimpleDir>();
    for (SimpleDir ds : workingSet){
    	
        if (keyIsOk(keyVal, ds) != negate){
        	newSet.add(ds);
        	System.out.println("Found " + (negate? "not " : "") + keyVal + " at (" +ds.x+","+ds.y+")");
        }
        else
        	System.out.println("Dit not find " + (negate? "not " : "") + keyVal + " at (" +ds.x+","+ds.y+")");
    }
    return newSet;
  }
  


  private boolean keyIsOk(PatternKeyValue pv, SimpleDir position) throws StandardError{
    Square foundSquare = this.game.getBoard().getSquareAt(position.x, position.y);
    switch (pv.toString()){
      case "friend":
        if (!friend(foundSquare))
          return false;
        break;
      case "foe":
        if (!foe(foundSquare))
          return false;
        break;
      case "empty":
        if (!empty(foundSquare))
          return false;
        break;
      default:
        throw new StandardError("Unrecognised pattern keyword: " + pv.toString());
    }
    return true;
  }
  
  private boolean friend(Square s) throws StandardError{
    for (Piece p : s.getPieces()){
      if (p.getOwner().equals(currentPlayer()))
        return true;
    }
    return false;
  }
  private boolean foe(Square s) throws StandardError{
    for (Piece p : s.getPieces()){
      if (!p.getOwner().equals(currentPlayer()))
        return true;
    }
    return false;
  }
  private boolean empty(Square s) throws StandardError{
    return s.getPieces().length == 0;
  }

}
