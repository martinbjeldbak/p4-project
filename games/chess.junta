type Chess[] extends Game["Chess"]{
	define players = [ ChessPlayer[ "Black" ], ChessPlayer[ "White" ] ]
	define board = let $black = players[0], $white = players[1] in
		ChessBoard[]
			.addPieces[ Pawn[ $black, s ], [ A7, B7, C7, D7, E7, F7, G7, H7 ] ]
			.addPieces[ Rook[ $black ],    [ A8, H8 ] ]
			.addPieces[ Knight[ $black ],  [ B8, G8 ] ]
			.addPieces[ Bishop[ $black ],  [ C8, F8 ] ]
			.addPieces[ Queen[ $black ],   [ E8 ] ]
			.addPieces[ King[ $black ],    [ D8 ] ]
			
			.addPieces[ Pawn[ $white, n ], [ A2, B2, C2, D2, E2, F2, G2, H2 ] ]
			.addPieces[ Rook[ $white ],    [ A1, H1 ] ]
			.addPieces[ Knight[ $white ],  [ B1, G1 ] ]
			.addPieces[ Bishop[ $white ],  [ C1, F1 ] ]
			.addPieces[ Queen[ $white ],   [ E1 ] ]
			.addPieces[ King[ $white ],    [ D1 ] ]
}	

type WhiteSquare[] extends Square[]
type BlackSquare[] extends Square[]
type ChessBoard[] extends GridBoard[ 8,8 ]{
	define squareTypes[] = [ WhiteSquare, BlackSquare ]
}

type ChessPlayer[ $color ] extends Player[]{
	
//	define winCondition[$game] = findSquares[ /King !isSecure/ ] // questionable!	
}

type ChessPiece[ $player ] extends Piece[ $player ]{
	define slide[ $game, $patterns ] =
		toActions[ union[ map[ $patterns, #[$pattern] =>
			findSquares[ / this ($pattern empty)* $pattern !friend/ ]
		] ] ]
	
	define toActions[ $list ] =
		map[ $list, #[$item] =>
			moveAndCapture[ this, $item ]
		]
}

type Pawn[ $player, $dir ] extends ChessPiece[ $player ]{
	define actions[$game] =
		if isFirstMove[this] then
			toActions[ findSquares[ / this ($dir empty)2 / ] ]
		else
			[]
		+	map[ findSquares[ / this ($dir empty) | (($dir e)|($dir w) foe) / ],
				#[ $square ] =>
					//Is it possible to move further one up on the board?
					if size[ findSquares[ $board, / $square $dir / ] ] == 0 then
						sequence[ moveAndCapture[ this, $square ], promote[ this, Queen ] ] //TODO: make it a user choice
					else
						moveAndCapture[ this, $square ]
			]
		//En pasant
		+	map[ filter[ / this e|w foe Pawn /, #[$square] =>
					let $foe = piecesOnSquare[$square][0],
						$turn = currentTurn[$game]
					in
						lastTurn[$foe] == $turn - 1 
						and history[ $turn ] == moveEx[ $foe, / $square $dir $dir /, $square ]
				],
				#[$square] => sequence[ move[ this, findSquares[/ $square $dir /][0] ], remove[ $foe ] ]
			]
}

type Rook[ $player ] extends ChessPiece[ $player ]{
	define actions[ $game ] =
		slide[ $game, [ n, w, s, e ] ]
}

type Knight[ $player ] extends ChessPiece[ $player ]{
	define actions[ $game ] =
		findMoveActions[ $game, this, /this (n ne|nw) | (s se|sw) | (e nw|se) | (w nw|sw) !friend/ ]
}

type Bishop[ $player ] extends ChessPiece[ $player ]{
	define actions[ $game ] =
		slide[ $game, [ ne, nw, sw, se ] ]
}

type Queen[ $player ] extends ChessPiece[ $player ]{
	define actions[ $game ] =
		slide[ $game, [ n, w, s, e, ne, nw, sw, se ] ]
}

type King[ $player ] extends ChessPiece[ $player ]{
	define actions[ $game ] =
		findMoveActions[ $game, this, /this e|n|s|w|ne|nw|se|sw !friend/ ]
}

