\section{Static semantics}
The \classref{ScopeChecker} is the class responsible for enforcing some of the static semantic rules of \productname{}, described in \chapref{chap:design}, at compile-time. This section is aimed to explain how these static semantic checks are performed by the \classref{ScopeChecker} in simple sequential steps. Any error detected by the \classref{ScopeChecker} will cause a \classref{ScopeError} exception to be thrown. This error contains helpful information about the type of error and where in the input program the error is located. 

\subsection{TypeVisitor}
The first visitor used is the \classref{TypeVisitor}. This visitor traverses the AST, finds all type definitions in the input program and for each type definition, an object of class \classref{TypeSymbolInfo} is instantiated. After running the \classref{TypeVisitor}, each type definition in the input program has an associated object of class \classref{TypeSymbolInfo} which makes it easy to get information about any type in the input program by accessing the following members contained in the \classref{TypeSymbolInfo} object:
\begin{itemize}
\item \classref{String} name: The type's name.
\item \classref{String} parentName: The name of its super type or null if not a derived type.
\item \classref{Integer} args: The number of arguments in the type's constructor.
\item \classref{Integer} parentArgs: The number of arguments given in the call to its parent constructor.
\item \classref{List of Data} data: Each data defined in the type body has a corresponding \classref{Data}-object describing its name and position in the input program. The input program position (IPP) is stored as a line and an offset and makes it possible to produce error messages with information about where in the input program an error was found.
\item \classref{List of Member} members: Each constant and function defined in the type body has a corresponding \classref{Member}-object describing its name, argument count, an abstract flag, a \classref{TypeSymbolInfo} reference to the type defining the \classref{Member} and IPP.
\item \classref{AstNode} node: A reference to the TYPE_DEF-\classref{AstNode} which defines the type. This reference is used to get the input program position but is also used for a special purpose described in \secref{sec:typetablecleaner} 
\item \classref{TypeSymbolInfo} parent: This will contain an object reference to its parent type if it has one. This is however a null pointer until running the \classref{TypeTableCleaner} described in \secref{sec:typetablecleaner}.
\end{itemize}

All the \classref{TypeSymbolInfo} objects are kept in an object of class \classref{TypeTable}. The \classref{TypeTable}-class is a layer of abstraction which provides easy and fast access information about the types contained in the input program. The underlying implementation is a hashmap from the type's name as a \classref{String} to its object reference, which provides quick lookup on type names, and a \classref{TypeSymbolInfo}-list, which makes iterating over the \classref{TypeSymbolInfo}'s convenient and makes it possible to sort the types with a purpose described in \secref{sec:typetablecleaner}. For convenience, we say that a type is added to a type table which means that a \classref{TypeSymbolInfo}-object representing the type is added to the \classref{TypeTable}-object representing the type table.

When a type is added to the type table, it is checked that no other types with the same name exists.

\subsection{TypeTableCleaner}
\label{sec:typetablecleaner}
The \classref{TypeSymbolInfo}-objects does only contain the name of their parent type as a \classref{String} or a null value if it is not a subtype. By making a lookup in the \classref{TypeTable} on the parent name, the real object references can be found and stored for faster and more convenient parent-chain lookups which is used by the \secref{sec:usesaredeclaredvisitor}.
A topological sort is done on the \classref{TypeSymbolInfo}-objects by calling the \classref{TypeTable}.\methodref{topologicalSort()}, such that when iterating over the type table, any type yielded will always appear before all of its subtypes. This makes it efficient to propagate members, a technique which purpose and implementation will now be explained. Notice that the topological sorting is eased by the fact that multiple inheritance is not allowed.

In \secref{sec:usesaredeclaredvisitor}, we will need a way to determine whether a function or a constant is visible in a given type. 
Visible means that the type itself or any super type contains the member. If we want to check if type G has a visible function foo[], we could first look in G and if not found, follow the parent-chain all the way from G up to A. Following these parent-chains would have to be done every time we need to know if any member is visible in any type. A much smarter approach is used though. Given that the types in the type table are topological sorted, we just iterate over them. If we meet a type C, we put the members in its parent type B in C as well. If B derives from A, we know that B has already gotten the members from A due to the topological sorting. This is the technique earlier mentioned as propagating members.

After having propagated the members, every type that contains any abstract members are marked as being abstract. This is done by changing the type of the \classref{AstNode} to an ABSTRACT_TYPE_DEF.

Due to the sorting criteria, a topological sort cannot be performed if an extend cycle exists, e.g: A extends B, B extends C and C extends A. The \classref{TypeTable}.\methodref{topologicalSort()} will detect a cycle and throw an error.

\subsection{UsesAreDeclaredVisitor}
\label{sec:usesaredeclaredvisitor}
%symbol table
%opening scope

%error handling, line and offsets are kept