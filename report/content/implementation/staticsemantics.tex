\section{Static semantics}
The \classref{ScopeChecker} is a visitor class that checks the static semantic rules of \productname{} at compile-time. It checks that any referenced variable or function (when talking about both types the term identifier will be used in this section) is declared in a visible scope (local or outer scopes). It also checks that no double declarations exists in the same scope. A variable can however be declared with the same name as a variable in an outer scope, in which case the new declaration hides the one in the outer scope. If an identifier is found to be undeclared, the \classref{ScopeChecker} will search for an identifier with a similar name in visible scopes and suggest the use of that identifier in the outputted error message, e.g. ``Syntax error: Function 'IsSometing' undeclared, did you mean 'IsSomething'? at line 8, offset 19''.

\subsection{The symbol table}
When traversing the AST, a symbol table is used to store the identifiers met. The symbol table uses the Java \classref{HashMap} to store KeyValue-pairs of  \classref{SymbolInfo}'s paired with a \typeref{Boolean}. The \classref{SymbolInfo} contains an \typeref{Integer} \variableref{name}, \typeref{SymbolType} \variableref{type}, \typeref{Integer} \variableref{line}, and \typeref{Integer} \variableref{offset}. The \typeref{SymbolType} \variableref{type} is an enumeration that indicates whether the symbol is a variable or a function. To use the built-in \classref{HashMap}-class in Java efficiently, the \classref{SymbolType} overrides the \methodref{getHasCode()} and \methodref{equals(\classref{Object} \varref{object})} method. The hash code generation and equality check is only based on the symbol's \varref{name} and \varref{type}. This means that two functions or variables with the same name but found on different lines or offsets is considered   equal, which is indeed the intention for a static semantic check.

\subsection{Opening a new scope}
When a \productname{}-construct is met that requires a new scope to be opened, for instance the \emph{let-in}-block, this is implemented by instantiating a new symbol table which references the previous active symbol table as its \classref{SymbolTable} \varref{parent}. The current active symbol table is referenced by \classref{SymbolTable} \varref{currentST} in \classref{ScopeChecker}. This approach makes it easy to search all scopes that encapsulates the current scope for a declaration of an identifier, by recursively searching the parent symbol table references. Determining whether an identifier met is a declaration or a use will be explained in \secref{sec:deccontext}.

\subsection{Closing a scope}
\label{sec:closescope}
When a scope is closed, it is checked that all variable uses in the active symbol table are actually declared in a parent symbol table. This check can be performed already, since any variable \textbf{must} be declared before it's use, due to the \emph{let-in}-semantics.
For functions, however, this is not true. The syntax of \productname{} determines that all functions must be declared in the start of a program. But since a function body creates a new scope and a function body can call another function not this declared after the end of the function body, the same check cannot be applied for functions when exiting a scope.
Consider the following \productname{} code-example:
\codesample{calltolaterdefinedfunction.junta}
When calling function $a$, $a$ calls $b$ which evaluates to $5$. When checking the static semantics, a new scope is opened when analysing function $a$. In this scope, a reference the function b is met. When the function body of a is exited and the scope closes, it cannot be checked already if the function b has been declared, since it is first declared on the next line. This problem is solved by using another approach for functions than for variables. When exiting a scope, all function uses in the current symbol table are transferred to the parent symbol table, except in one case, where the closed symbol table is the global scope (it's parent symbol table is undefined). When closing the global scope, it is checked that all function uses have a declaration. This approach can only be used because \productname{} does not allow nested function definitions.

Finally, when any scope is closed the \varref{currentST} will be updated to reference the current symbol table's parent, namely \varref{currentST}.\methodref{getParent()}. This means that the traversal of the AST actually implements a stack of symbol tables that expands and detracts regarding to the nesting of its location in the AST.

\subsection{Predefined functions}
When the \classref{ASTNode} \varref{PROGRAM} is visited, the global scope is opened and the default functions contained in \productname{}, such as \methodref{findSquares[]}, \methodref{union[]}, etc., is placed in this scope. The children of the \classref{ASTNode} is then visited which contains the entire program. Thereby, after the call to \methodref{visitChildren()}, the scope is closed, which causes the check for use of undeclared functions, described in \secref{sec:closescope}, to be performed.

\subsection{Declaration contexts}
\label{sec:deccontext}
The visitor pattern makes it convenient to find the identifiers contained in a \productname{}-program. Any use of a function is handled by overwriting the \methodref{visitFunction(}, provided by the \classref{Visitor} as well as a function declaration is handled by overriding the \methodref{visitFuncDef()}.
Any variable, whether a use or a declaration is handled by the \methodref{visitVar}-method. Since it is not known if the variable name contained in the node is a declaration or a usage, a global variable \typeref{Boolean} \varref{varDeclarationMode} is set to true when visiting an \classref{ASTNode}, that causes all children \typeref{VAR}-\classref{ASTNode}'s to be declarations, or false otherwise. E.g., when meeting a function call, the \varref{varDeclarationMode} is set to \typeref{false} before visiting the actual parameters of the function call, but visiting the formal parameters of a function definition  

\subsection{ScopeError-exception}
When an error is found during the static semantics check, an exception is thrown. The exception contains information about identifier causing a problem, and it's line and offset, which will help the programmer identify the error's location. All enclosing symbol tables are recursively searched for an identifier similar to the one causing the error, which will be suggested in the error message. This similarity-check is performed using a Levenshtein-algorithm and allowing a maximum distance of 2. This allows up to two misplaced characters, for instance a missed keystroke or two swapped characters.