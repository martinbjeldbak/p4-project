\section{Parser}

In this section we present our handwritten parser for our programming language. We have written a recursive descent parser, which is within the class of LL(1) parsers. The grammar for our programming language is suiting for this because e.g. is does not have left-recursive productions. 

%structured as the grammar
The parser was very simple to implement, because it is structured in the same manner as the grammar is structured. For instance if the grammar expresses that the next set of terminals must begin with a left bracket (`[') then the parser will expect the next token to be a \tokenref{LBRACKET} which is the token name for a left bracket. 

%discuss the if expression
In \lstref{lst:ifexpr} we give an example of how this structure looks like in the parser. The following production rule from our grammar shows what the if expression expects:

\begin{ebnf}
\grule{if\_expr}{\gter{if} \gcat expression \gcat \gter{then} \gcat expression \gcat \gter{else} \gcat expression}
\end{ebnf}

The production for if expression says that every expression of this type must start with the combination of the two symbols \gter{i} and \gter{f} that spell the word \gter{if}. When the parser meets this word it knows that it has to parse an if expression and the code this is reflected in \lstref{lst:ifexpr}.

\lstinputlisting[caption="This shows how if expressions are parsed.", label=lst:ifexpr, language=Java]{listings/ifexpr.java}

%astNode()
In \lstref{lst:ifexpr} the parser initialises the node for the expected if expression. The parser starts by calling the method \methodref{astNode} to create a node for the Abstract Syntax Tree (AST). We call the method with information about what type of expression this is (\tokenref{IF\_EXPR}). The method calls the \methodref{expect}-method to verify that the next token is what we are expecting. If the two tokens do not match the parser throws a syntax error with information about the error.

%Token
Every grammar has a finite set of nonterminals and terminals that constitute the productions of the grammar. We have defined tokens for every nonterminal in the grammar. The if expression have the token name of IF\_EXPR. 

%node.addChild(expression())
In the production for the if expression we have three terminals; the \gter{if}, \gter{then}, and the \gter{else}. These are all expected in the method for any if expression. When the parser finishes reading a terminal it knows that the following token will be an expression, and therefore a new child for the node is made with a call to the \methodref{expression}-method wherein we parse expressions. Finally the method returns the node containing every child for the whole if expression.

%lookAhead methods - Element
We mentioned earlier that the parser is an LL(1) parser which means that the parser is able to look ahead in the sequence of tokens. We have shown the look ahead method to determine if the next token is part of an element. Recall that the productions for the nonterminal is as follows:

\begin{ebnf}
\grule{element}{\gter{(} \gcat expression \gcat \gter{)}}
\galt{variable}
\galt{list}
\galt{pattern}
\galt{keyword}
\galt{direction}
\galt{coordinate}
\galt{integer}
\galt{string}
\galt{identifier}
\galt{function}
\end{ebnf}

This means that an element can be quite a few things. This is why we have constructed a method to determine whether the next token is part of an element. This method is shown in \lstref{lst:lookaheadelement}.

\lstinputlisting[caption="This shows what the lookAhead method expects for an element as input.", label=lst:lookaheadelement, language=Java]{listings/method_lookAheadElement.java}

The method \methodref{lookAheadElement} makes use of two methods to figure out of the next token is part of an element. The first method is the \methodref{lookAhead}-method that takes a token as an argument and figures out if the next token in the sequence of tokens are equal to each other. The second method is like the method in \lstref{lst:lookaheadelement} but instead of checking for elements it checks for literals. Literals are one of four tokens; the \tokenref{direction, coordinate, integer} and \tokenref{string}. These are what the method \methodref{lookAheadLiteral} checks for. These methods return true or false.

%example of lookAheadElement
%LL(1)
In \lstref{lst:examplelookahead} we show an example of how the \methodref{lookAhead}-method is used in the parser. The example is taken from the \methodref{expression}-method. Recall that the production for an expression is as follows:

\begin{ebnf}
\grule{expression}{function\_call}
\galt{element \gcat operator \gcat expression}
\galt{if\_expr}
\galt{lambda\_expr}
\galt{element}
\end{ebnf}

The grammar shows that an element can be followed by an operator or nothing. If the element is followed by an operator, then the operator is followed by a new expression. This must be reflected in the code of the parser.

\lstinputlisting[caption="Use of the \methodref{lookAhead}-method. This example is from the \methodref{expression}-method.", label=lst:examplelookahead, language=Java]{listings/example_lookAheadElement.java}

The code in \lstref{lst:examplelookahead} shows that the if-statement uses the \methodref{lookAheadElement}-method to determine if the next token is an element. If this is true, it enters the block of code inside the statement and creates a new node called ``element'' for this token. As we are inside the production for an expression the next thing the code checks for is if the next token after the \tokenref{element} is the type of an operator. The \methodref{accept}-method returns true if the types correspond, and false if they don't. If the method returns true, the parser enters the block of code and adds a new node called ``operation'' with two children - the element-node just created and a new node called ``expression'', because the parser knows that the operator must be followed by an expression. Finally it adds the operation-node to the original node of the whole method called ``node''.
However, if this is not the case, the code just return the new node called ``element'' as a child for the node of the node of the whole expression. 

When the parser has parsed every token of the input it can produce an Abstract Syntax Tree that corresponds to the program written in the programming language. This shows that the parser is built very systematically according to the grammar of the programming language.