\section{Parser}

In this section we present our handwritten parser for our programming language. We have written a recursive descent parser, which is within the class of LL(1) parsers. The grammar for \productname{} is suited for this because e.g. is does not have left-recursive productions. 

%structured as the grammar
The parser was very simple to implement, because it is structured in the same manner as the grammar is structured. For instance if the grammar expresses that the next set of terminals must begin with a left bracket (`[') then the parser will expect the next token to be a \tokenref{LBRACKET} which is the token name for a left bracket. 

%discuss the if expression
In \lstref{lst:ifexpr} we give an example of how this structure looks like in the parser. The following production rule from our grammar shows what the if expression expects:

\begin{ebnf}
\grule{if\_expr}{\gter{if} \gcat expression \gcat \gter{then} \gcat expression \gcat \gter{else} \gcat expression}
\end{ebnf}

The production for if expression says that every expression of this type must start with the combination of the two symbols \gter{i} and \gter{f} that spell the word \gter{if}. When the parser meets this word it knows that it has to parse an if expression and the code this is reflected in \lstref{lst:ifexpr}.

\lstinputlisting[caption="This shows how if expressions are parsed.", label=lst:ifexpr, language=Java]{listings/ifexpr.java}

%astNode()
In \lstref{lst:ifexpr} the parser initialises the node for the expected if expression. The parser starts by calling the method \methodref{astNode} to create a node for the Abstract Syntax Tree (AST). We call the method with information about what type of expression this is (\tokenref{IF\_EXPR}). The method calls the \methodref{expect}-method to verify that the next token is what we are expecting. If the two tokens do not match the parser throws a syntax error with information about the error.

%Token
Every grammar has a finite set of nonterminals and terminals that constitute the productions of the grammar. We have defined tokens for every nonterminal in the grammar. The if expression have the token name of IF\_EXPR. 

%node.addChild(expression())
In the production for the if expression we have three terminals; the \gter{if}, \gter{then}, and the \gter{else}. These are all expected in the method for any if expression. When the parser finishes reading a terminal it knows that the following token will be an expression, and therefore a new child for the node is made with a call to the \methodref{expression}-method wherein we parse expressions. Finally the method returns the node containing every child for the whole if expression.

%lookAhead methods - atomic
We mentioned earlier that the parser is an LL(1) parser which means that the parser is able to look ahead in the sequence of tokens. We have shown the look ahead method to determine if the next token is part of an atomic-expression. Recall that the productions for the nonterminal is as follows:

\begin{ebnf}
\grule{atomic}{\gter{(} \gcat expression \gcat \gter{)}}
\galt{variable}
\galt{list}
\galt{\gter{/} \gcat pattern \gcat \gter{/}}
\galt{\gter{this}}
\galt{\gter{super}}
\galt{direction}
\galt{coordinate}
\galt{integer}
\galt{string}
\galt{type}
\galt{constant}
\end{ebnf}

This means that an atomic-expression can derive quite a few productions. This is why we have constructed a method to determine whether the next token is part of an atomic-expression. This method is shown in \lstref{lst:lookaheadatomic}.

\lstinputlisting[caption="This shows what the lookAhead method expects for an atomic-expression as input.", label=lst:lookaheadatomic, language=Java]{listings/method_lookAheadAtomic.java}

The method \methodref{lookAheadAtomic} makes use of two methods to figure out of the next token is part of an atomic-expression. The first method is the \methodref{lookAhead}-method that takes a token as an argument and figures out if the next token in the sequence of tokens are equal to each other. The second method is like the method in \lstref{lst:lookaheadatomic} but instead of checking for elements it checks for literals. Literals are one of four tokens; the \tokenref{direction, coordinate, integer}, and \tokenref{string}. These are what the method \methodref{lookAheadLiteral} checks for. These methods return true or false.

%example of lookAheadAtomic
%LL(1)
In \lstref{lst:examplelookahead} we show an example of how the \methodref{lookAhead}-method is used in the parser. The example is taken from the \methodref{expression}-method. Recall that the production for an expression is as follows:

\begin{ebnf}
\grule{expression}{assignment}
\galt{if\_expr}
\galt{lambda\_expr}
\galt{\gter{not} \gcat expression}
\galt{operation}
\end{ebnf}

The production of an expression is reflected in the code of the parser. An example of this is given in \lstref{lst:examplelookahead}.

\lstinputlisting[caption="Use of the \methodref{lookAhead}-method. This example is from the \methodref{expression}-method.", label=lst:examplelookahead, language=Java]{listings/example_lookAheadAtomic.java}

The code presented in \lstref{lst:examplelookahead} is a small section of the \methodref{expression} method. We have removed code from the section which is not relevant for the example we are trying to show. The removed code is presented as \{...\}. In \lstref{lst:examplelookahead} we wish to present how the \methodref{lookAhead} methods are used.

An assignment begins with the reserved word \gter{let} and the first \methodref{lookAhead} method peeks for exactly that token to determine if the next production is an assignment. If method returns true that the next token is in fact the \gter{let} word, then the parser enters a new method namely the \methodref{assignment} method which checks to determine if the rest of the production is correctly written. The same is done for the if expression, lambda expression and operation.

The operation production is a bit different, because it needs two look ahead methods to determine if the next production is an operation. An operation can begin with either an atomic value or a not-operator. So the code uses a \methodref{lookAheadAtomic} and a regular \methodref{lookAhead} with the specific token as a parameter to check if the next production is an operation.

The methods return nodes which are connected with each other to an AST.
When the parser has parsed every token of the input it can produce an AST that corresponds to the program written in \productname{}. This shows that the parser is built very systematically according to the grammar.
