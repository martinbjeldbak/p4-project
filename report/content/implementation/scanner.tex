\section{Scanner}
\label{sec:scannerimplementation}
This section presents our implementation of a scanner for our programming language.

Our scanner takes raw source code in the form of a program written in
\productname{} as input. It validates the lexical correctness of a
\productname{} program, which means that it tries to determine if the
input is in the language of \productname{}. It does so by identifying
tokens defined in \productname{} from the input. If an input is met
which cannot be recognized as a valid token, the source code is not
a valid program in \productname{}, hence an exception is thrown, and
scanning stops. The exception contains information about the line and
offset at which the input was determined to be incorrect.

The strings which are converted to tokens are called lexemes. Many
lexemes can be converted to the same type of token. Programs will
typically contain many different identifiers, which in \productname{}
will be treated as an \tokenref{ID} token. The name of the identifier will
then be saved as a value belonging to the particular token.

\tab[8cm]{lexemestotokens}{1}{Analysing an input stream for lexemes and tokens.}
                 {		     }
       {Lexemes	}{\textbf{Tokens}    }{
\tabrow{Black 	}{ IDENTIFIER (Black)}
\tabrow{\{    	}{ LBRACE 	     }
\tabrow{Pawn  	}{ IDENTIFIER (Pawn) }
\tabrow{$[$    	}{ LBRACKET	     }
\tabrow{A7    	}{ COORD\_LIT(A7)    }
\tabrow{B7    	}{ COORD\_LIT(B7)    }
\tabrow{C7    	}{ COORD\_LIT(C7)    } 
\tabrow{D7    	}{ COORD\_LIT(D7)    }
\tabrow{E7    	}{ COORD\_LIT(E7)    }
\tabrow{F7    	}{ COORD\_LIT(F7)    }
\tabrow{G7    	}{ COORD\_LIT(G7)    }
\tabrow{H7    	}{ COORD\_LIT(H7)    }
\tabrow{$]$	}{ RBRACKET 	     }
\tabrow{\}    	}{ RBRACE	     }
}

Our scanner consists of two classes: \classref{Scanner} and
\classref{Token}. \classref{Token} contains an enum named
\classref{Type} that includes all the types of tokens in \productname{}.

When a lexeme is found in the input stream, the scanner analyses which
token type it belongs to. A new token is then instantiated and returned
by the scanner. The constructor for \classref{Token} takes the following
arguments: (\classref{Token.Type}, \textit{line}, \textit{offset}). The
\textit{line} and \textit{offset} represent where in the source code the
lexeme of any token was found. This is essential if an error is found,
since it is possible for the scanner to inform the programmer where in
the source code an error exists.

When an input is to be analysed the scanner looks at the first symbol
of the input, which is not a blank or white space character. Based on
the first character, it makes a jump to a method. The method is
then responsible for determining which kind of token that is supposed to
be generated. With this approach we have constructed a DFA with explicit
control. The explicit control means that the transitions are handled
``manually'' using conditional jumps to method rather than having
a table driven automaton with defined states and a transition table.

In \lstref{lst:scan} you can see many methods of the style
\methodref{is{\textit{Something}}()} for instace \methodref{isDigit()}
and \methodref{isOperator()}. These functions check the first character
in an input and checks if the next symbol in the input stream is
that ``\textit{Something}''. \methodref{isWhitespace()} checks if
the next input character (\varref{nextChar}) is a white space.
While true \methodref{pop()} dequeues the next symbol in the input
stream and updates \varref{nextChar}. Therefore, the while loop with
\methodref{isWhitespace()} removes all initial white spaces before a
next token is found. If, at any time, the scanner has reached the end of
the input stream it returns a \tokenref{EOF} so succeeding parts of the
parser knows where the program ends.

Beside the \methodref{isWhitespace()} function, all other functions
of the form \methodref{is{\textit{Something}}()} are responsible for
returning a token based on their evaluation of the input stream.
For example, if the first symbol of a lexeme is an upper case
character, the function \methodref{scanUppercase()} is responsible
for determining whether the lexeme is a \tokenref{type} or a
\tokenref{coordinate} because they are the only two tokens starting
with an upper case character in \productname{}. This is depicted in
\tableref{table:scanner}.

\tab[14cm]{scanner}{2}{The different groupings of characters, the method
responsible for handling them and the possible returned token types.}
                         {Action and output					            }
       {First character	}{Responsible function	& Token type				    }{
\tabrow{White space 	}{			& \textit{ignored}			    }
\tabrow{End of file    	}{			& EOF					    }
\tabrow{Digit		}{scanNumeric()		& LIT\_INT				    }
\tabrow{Uppercase    	}{scanUppercase()	& LIT\_COORD, TYPE		 	    }
\tabrow{''		}{scanString()		& LIT\_STRING				    }
\tabrow{\$    		}{scanVar()		& VAR					    }
\tabrow{Operator    	}{scanOperator()	& OP\_PLUS, OP\_MINUS, OP\_MULT,
						  OP\_DIV, OP\_MODULO, OP\_ASSIGN, $\ldots$ }
\tabrow{Lowercase   	}{scanKeyword()		& KEY\_THIS, KEY\_SUPER, KEY\_DEFINE,
						  KEY\_ABSTRACT, KEY\_EXTENDS, $\ldots$	    }
}

Two variables, \typeref{int} \varref{offset} and \typeref{int}
\varref{line} keep track of where in the source file the next input
character is taken from. The function \methodref{pop()} will pop
the first character from the input stream and assign the value of
the new first character to the variable \varref{nextChar}. The
\methodref{is{\textit{Something}}()} functions use the \varref{nextChar}
to check what kind of character the next one is. The \methodref{pop()}
function will additionally increment \varref{offset} by one. If
the next input symbol is a new line character, it assigns zero to
\varref{offset} and increments \varref{line} by one. If an unexpected
input symbol is met, a \typeref{SyntaxError} exception is thrown. An
example could be a \$ character followed by white space. \$ is used as
prefix for variables, and expects to be followed by an identifier, e.g.\
\$\varref{varName}. For more information on our error handling, refer to
\secref{sec:errorhandling}.
 
\lstinputlisting[caption={The scan() method from the \productname{} scanner.}, label=lst:scan, language=Java]{listings/scan.java}

When a syntactically correct program is accepted by the scanner, a
stream of tokens is created. These tokens are then fed to the parser,
which analyses them and creates an abstract syntax tree of nodes based
upon the supplied tokens.
