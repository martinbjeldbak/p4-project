\section{Scanner}
Our scanner takes a raw source code for a program written in \productname{} as input. It validates the lexically correctness of a \productname{} program, which means that it tries to determine if the input is in the language of \productname{}. It does so by identifying tokens defined in \productname{} from the input. If an input is met which can not be recognized as a valid token, the source code is not a valid program in \productname{}, hence an exception is thrown. The exception contains information about the line and offset at which the input was determined to be incorrect.
 The strings which are converted to tokens are called lexemes. Many lexemes can be converted to the same type of token. Programs will typically contain many different identifiers, which in \productname{} all will be treated as an \tokenref{ID}. The name of the identifier will then be saved as value belonging the particular token.

\tab[8cm]{lexemestotokens}{1}{Analysing an input stream for lexemes and tokens.}
                 {Tokens}
       {Lexemes	}{						}{
\tabrow{Black 	}{ IDENTIFIER (Black)	}
\tabrow{\{    	}{ LBRACE 				}
\tabrow{Pawn  	}{ IDENTIFIER (Pawn)	}
\tabrow{$[$    	}{ LBRACKET				}
\tabrow{A7    	}{ COORD\_LIT(A7)		}
\tabrow{B7    	}{ COORD\_LIT(B7)		}
\tabrow{C7    	}{ COORD\_LIT(C7)		}
\tabrow{D7    	}{ COORD\_LIT(D7)		}
\tabrow{E7    	}{ COORD\_LIT(E7)		}
\tabrow{F7    	}{ COORD\_LIT(F7)		}
\tabrow{G7    	}{ COORD\_LIT(G7)		}
\tabrow{H7    	}{ COORD\_LIT(H7)		}
\tabrow{$]$		}{ RBRACKET 			}
\tabrow{\}    	}{ RBRACE				}
}

Our scanner contains 2 classes, \classref{Scanner} and \classref{Token}. \classref{Token} contains an enum named \classref{Type} that enumerates all the types of tokens in \productname{}. When a lexeme is found in the input stream, the scanner analyses which token type it belongs to. A new token is then instantiated and returned by the scanner. The constructor for \classref{Token} takes the arguments (\classref{Token.Type}, \textit{line}, \textit{offset}). The \textit{line} and \textit{offset} represent where in the source code the lexeme of any token where found. This is essential if an error is found, since we can then inform a programmer where in his source code he should look for the error.
 
When an input is to be analysed, the scanner looks at the first symbol of the input which is not a blank character. Based on the first character it makes a jump to a subfunction. The subfunction is then responsible for determining which kind of token can be generated. With this approach we have constructed a DFA with explicit control. The explicit control means that the transitions are handled ``manually'' using conditional jumps to subfunctions, rather than having a table driven automate with defined states and a transition table.
In \lstref{lst:scan}, you can clearly see many functions with the name \methodref{isSomething()}. These functions checks the first character in an input and checks if the next symbol in the input stream is ``Something''. \methodref{isWhitespace()} checks if the next input character (\varref{nextChar}) is a white space. While true, \methodref{pop()} dequeues the next symbol in the input stream and updates \varref{nextChar}. Therefore, the while loop with \methodref{isWhitespace()} removes all initial white spaces before a next token is found. If at any time, the scanner has reached the end of the input stream, it returns a \tokenref{EOF} so succeeding parts of the parser know where the program ends.

Beside the \methodref{isWhitespace()} function, all other \methodref{isSomething()} functions, is reponsible for returning a token based on their evaluation of the input stream.
For example, if the first symbol of a lexeme is an upper-case character, the function \methodref{scanUppercase()} is responsible for determining whether the lexeme is an \tokenref{identifier} or a \tokenref{direction}, because they are the only tokens starting with an upper-case character in \productname{}. This is depicted in In \figref{fig:scanner}. Two variables, \typeref{int} \varref{offset} and \typeref{int} \varref{line} keeps track of where in the source file the next input character is taken from. The function \methodref{pop()} will pop the first character from the input stream and assign the value of the new first character to the variable \varref{nextChar}. The \methodref{isSomething()} functions uses that \varref{nextChar} to check what kind of character the next one is.
The \methodref{pop()} function will additionally increment \varref{offset} by one. If the next input symbol is a new line character, it assigns zero to  \varref{offset} and increments \varref{line} by one. If an unexpected input symbol is met, a \typeref{SyntaxError}-exception is thrown. An example could be a \$ character follow by a white space. \$ is used as prefix for variables, but expects to be followed by an identifier, e. g. \$\varref{varName}.
\fig[width=0.5\textwidth]{scanner}{The different groupings of characters, the subfunctions responsible for handling them and the possible returned token types.}

 
\lstinputlisting[caption="The scan() method from the \productname{} scanner.", label=lst:scan, language=Java]{listings/scan.java}
