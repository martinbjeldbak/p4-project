\section{Interpreter}
The final step is the interpretation of the AST generated by the parser.
Here choices are taken based on the different node types in the tree
for a given program. This interpreter class is, like the scope checker,
also implemented with the visitor pattern, visiting all the nodes and
taking appropriate actions depending on what type of node is visited.
The difference here is that values, types, and other language constructs
are created and evaluated directly, propagating the values up the AST.

In this section, we will look at the inner workings of the interpreter
and see some examples of the different evaluation methods used and how
they're created. We also see how the symbol table keeps track of scopes
and the different values. Thereafter the implementation of patterns is
described, as they play a central role in most programs and functions
written in \productname{}.

\subsection{Symbol table and scopes}
Symbol tables in the interpreter are used to add and get constants, variables, types, and to push and pop the scope stack.

\subsection{Values and their operators}
Each one of our base values is represented internally by a class used in the interpreter. These classes are all sub-classes of a general class \classref{Value}, that offers the sub-classes an interface to implement various different operations, such as comparison, addition, calling, and so on, throwing an error if trying to use the operator between incompatible values or if the operation yields an invalid result.

In the following part of this section, a few important values and their features are highlighted.

\subsubsection{Coordinates}

\subsubsection{Lists}

\subsubsection{Types}
% Abstract type values are just an extension of types

\subsubsection{Functions}

% Our types are probably most interesting to mention here?


\subsection{Pattern evaluation}

\subsection{Evaluation of interpreter}
It is obviously not the fastest implementation of an interpreter, but we don't see that as a hindrance, because speed is not what we're after.

Under development, we have kept flexibility in mind, allowing us to easily add new base values and extend and maintain the feature set and semantics of our language, without having to change any existing code.
