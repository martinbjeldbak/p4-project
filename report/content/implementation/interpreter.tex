\section{Interpreter}
\label{sec:interpreter}

In this section we will look at the inner workings of the interpreter
and see some examples of the different evaluation methods used and how
they're created. We introduce how we have implemented scopes and their symbol
tables in \secref{sec:symboltableandscopes}. Afterwards, we introduce our
implementation of values and operators in \secref{sec:valuesandtheiroperators}.
Furthermore, we introduce our implementation of patterns in 
\secref{sec:patternmatching}. These patterns play a central role in most programs 
written in \productname{}.

The final step is the interpretation of the AST generated by the parser
(and possibly being modified slightly during scope checking). Here
choices are made based on the different node types in the tree for a
given program. This interpreter class is, like the scope checker, also
implemented with the visitor pattern, visiting all the nodes and taking
appropriate actions depending on what type of node is visited. The
difference here is that values, types, and other language constructs are
created and evaluated directly, propagating the results up the AST, and
that every type of node is visited, as each node is significant in that
they carry important information about the written program.

The implementation of the interpreter consists of $40$ visitor methods,
excluding private helper methods, each providing a specific behaviour
depending on the type of node visited, possibly calling other visit
methods on the node to evaluate to get a \classref{Value}.

% To add (maybe a section here about how the interpreter behaves?):
% The game env is loaded on startup
% Methods are created for each type of node, possibly visiting other nodes and
% passing values around

\subsection{Symbol table and scopes}
\label{sec:symboltableandscopes}
Symbol tables in the interpreter are used to add and get constants,
variables, types, and to push and pop scopes. The interpreter keeps a
single, global instance of a root symbol table which it calls methods
upon when needed. This symbol table is unaffiliated with the scope
checker's symbol table, which is constructed differently, and hence does
not share any information with it at all.

As an example of how the symbol table is operated, an example of
visiting an assignment (let-in) node, which utilizes some of these
features, is shown below:

\lstinputlisting[caption={\emph{Code taken from the interpreter to
show how the symbol table is used when visiting let-expressions.}},
label={lst:let}, language=Java]{listings/visitAssignment.java}

Listing \ref{lst:let} shows how let expressions are evaluated
when the abstract node type shown in \secref{sec:letexpressions} is
visited. A new scope is pushed onto the current stack of scopes,
whereafter the variables are pushed into the scope that was
just opened. Because let expressions, like all \productname{}'s
expressions, return a \classref{Value}, this value is retrieved after
the body of the assignment is computed but before the scope is closed,
as we will most likely need the values of the different variables.

\subsection{Values and their operators}
\label{sec:valuesandtheiroperators}
Each one of the base values offered by \productname{} is represented
internally by a class written in the interpreter. These classes are
all subclasses of a general class \classref{Value}, that offers the
subclasses an interface to implement various different operations, such
as comparison, addition, calling, and so on, throwing an error if trying
to use the operator between incompatible values or if the operation
yields an invalid result.

In the following part of this section, a few important values and their
features are highlighted. The most basic values such as integers,
strings, directions, coordinates, and lists principally support the
same operations, and are therefore relatively uninteresting to discuss
compared to the more complex values, such as types and functions. For
completeness, the implementation of coordinates, types, and
functions are discussed below.

Most properties (variables) of values are declared as Java
\classref{final}, due to the fact that \productname{} is functional and
that the result of an expression always results in a new instance of an
object. This means that a simple plus operation yields a new value, so
the interpreter constantly instantiates these new values without ever
needing to update a specific property, possibly leaving many young, dead
objects on the heap for Java's garbage collection to deallocate.

\subsubsection{Coordinates}
Coordinates are represented internally by a tuple $(x, y)$ specifying a
coordinate on the game board. The maximum board size is limited by an $x$ and
$y$, which are both 32-bit signed two's compliment Java integers.
\footnote{ Which gives a maximum coordinate of (\num{2147483647}; \num{2147483647}).
Much more than any realistically imaginable board game!}
If we wished to represent larger boards, we could simply use a built-in larger
natural number representation, or create a custom representation.

As specified in \secref{sec:standardenvironment}, coordinates consist of
a horizontal axis represented by a letter, or multiple letters, $x$, and a
numeral $y$, representing the vertical squares on a grid-shaped board.
When displaying a coordinate to the user, a simple method is called to
convert the $x$ coordinate to its alphabetical form.

Coordinate values support equals comparison, done by value. It also allows
addition with strings, directions, and lists which is described in
\secref{sec:validoperands}. Listing \ref{lst:coordSubtract} shows the
implementation of the subtraction operation on coordinates.

\lstinputlisting[caption={\emph{How subtraction of other values on \classref{Coordinate} is handled.}}, label={lst:coordSubtract}, language=Java]{listings/coordSubtract.java}

The method shown in the listing is principally the same implementation for every
mathematical operation across all the different above-mentioned subclasses of
\classref{Value}. Type checking is always done to see if the right-hand side
(RHS) of
the operation is compatible before taking the correct actions. The method
\methodref{is} on all \classref{Value} types, checks to see if the type is the
specified type or any subtype extending the type in \productname{}. If the RHS
is allowed, it is casted up to the appropriate type if it isn't used directly,
whereafter the appropriate operation is performed between the two types.

%\subsubsection{Lists}
%Lists are implemented very much like Coordinates, supporting comparison,
%addition with other lists and any singular \classref{Value}-type,
%subtraction also with other lists and singular \classref{Value}-types
%existing in the current \classref{List} being subtracted from.
%
%The most interesting feature of \classref{List} types is that they take
%an optional list of one to two parameters, allowing access to an element
%at a specific index in the list, or defining a range of indexes desired
%in the list, resulting in a new list containing the elements between the
%two indexes.


\subsubsection{Types}
\classref{Type} values are one of the more complex subclasses of
\classref{Value}, as they, when defined, can have formal parameters, a parent
\classref{Type}, and a complex body. These are all represented and stored
internally in a class \classref{Type}, instantiated when visiting a type
definition node (defined in \apref{ap:typedef}).

% Declaring
There are a handful of different ways to instantiate a \classref{Type}, all
depending on the contents of the type definition node visited.  If a type is
declared to have a parent, a \classref{Value} of type \classref{Type} is simply
instantiated by the interpreter with the appropriate constructor, saving the
nodes for the parent and the parents formal parameters. If the type declaration
also has a body, then each declaration is added to the newly instantiated type
by the interpreter.  Finally, the type is added to the symbol table, so it can
be called and instantiated at a later point in the program.

% Instantiating
Types are implemented to allow instantiating the type, returning a
\classref{ObjectValue} subclass with the actual parameters bound to the formal
parameters, scope bindings, and a reference to the interpreter so it can
evaluate the methods in its body (if one exists) when called. This
instantiation is done when the interpreter visits an actual type, where it looks
up the type's name in the symbol table, returning it if found, or an error if
not.

% Abstract types
Abstract type values are an extension of \classref{Type}, but only consisting of
abstract members, and do not allow instantiation, throwing a
\classref{TypeError} if attempted.

% Quick mini-summary
Unfortunately, the methods that make up the interface to the \classref{Type}
class are too large to be shown in this section, therefore we refer to the
\classref{TypeValue} class in the source code for a quick overview. The body of
types can consist of constants and functions, where the implementation of
functions is described blow.

\subsubsection{Functions}
Functions are yet another subclass of the \classref{Value} type,
though only supporting the addition operation to store the function in
a \classref{ListValue} (letting functions be first-class citizens).
Functions are represented internally as constants, and can therefore be
defined in the global scope or within any subscope that may exist, each
updating the symbol table's current scope's constant declarations.

% Creating function values 
Functions are created with the AST node expression body, which is
stored and not evaluated until the function is called. Functions
do not keep track of their own names, making it the interpreter's
symbol table's job. This allows lambda expressions to also have the
same type. Functions therefore merely incorporate formal parameters
and an expression, the body of the function. Functions also allow
the ability to have a variable list of formal parameters. If the
function is a lambda expression, then the current scope is passed to
the \classref{FunValue} when instantiating. This is because the lambda
expression is evaluated when declared. On the other hand, if a function
is declared with a name identifying it, the interpreter adds it to the
symbol table's constant table (thereby also keeping track of scope),
instantiating a \classref{FunValue} with the AST node expression and AST
node formal parameters allowing it to be accessed in the symbol table
when called.

% Calling a function
When a function is executed, it is called with a reference to the interpreter
and the actual parameters passed to the function. The interpreter is needed to
evaluate the body, and is used for access to the symbol table for scopes to add
and look up variables and functions, and so forth. For optimisation, an error is
thrown if the length of the actual parameter(s) does/do not match the length of
the formal parameter(s), already short-circuiting the call if attempted. Else
the function body is evaluated with the actual parameters in a new, temporary
scope that only exists while the call is running. This is done by calling the
interpreter's visit method on the root body node, resulting in a
\classref{Value} that the function returns. This scope has the previous scope as
a parent, giving it complete access to all the existing, declared members
outside the function's body.

% Tail recursion detection
An interesting feature of the interpreter in respect to functions is tail
recursion detection and optimisation. Special action is taken during the call
when this form of recursion is detected, converting it to an iterative loop
instead. An example of a tail recursive function, a small method
\methodref{recsum} that makes use of it, is seen below:

\codesample{tailrecursion.junta}

This simple function adds the first $N$ integers, where $N$ is defined as the
first parameter to the function. The tail recursion optimiser converts the
recursive function into a loop if it detects a trail recursion construction,
guaranteeing stack overflow prevention when using tail recursion in
\productname. How tail recursion is detected by the function when it is called
is shown by the pseudocode below:

\input{figures/tailrecursionalgorithm}

Here it is important to note that an internal \classref{Value} class \classref{CallValue} is used to keep track of the
returned body after being evaluated, making the check on line number $15$ in
\lstref{alg:tailrecursion} possible and true if it's the second or more time executing the body. This is done by having a boolean outside
the call initially set as false, and being switched to true upon executing the
body. Since a recursive function calls its own body again, a check on the
boolean is done to see if this is the case (line $1$). If the boolean is set, a different,
internal value \classref{CallValue} is created with a reference to the
\classref{Interpreter} and current \classref{FunValue} classes, and the function's
actual parameters, all possibly being effected by the function.

\subsection{Pattern matching}
\label{sec:patternmatching}
Patterns in \productname{} are a very important feature, being used in pretty
much every one of our test programs to evaluate winning conditions, find squares
or actions that have a specific property, and various other constructs.

\subsubsection{Failed implementation with finite automaton}
We looked at other languages in an attempt to find an existing solution to a
similar problem and quickly found that patterns should be very similar to
regular expressions. Unfortunately, regular expressions actually do not share
the same properties as our patterns, ending up giving us quite a headache when
trying to use automaton to describe patterns. One of the primary troubles we had
using automatons was the fact that automatons take an input stream and decide
whether the input is to be accepted or rejected. For a pattern matching, an
input stream can be seen as a path between two squares on the board. For a
person who plays a \productname{} game, it is however not convenient that he has
to specify the exact path he wants to move. Consider trying to move the knight
from B1 to C3 in a game of chess. Such a move could be chosen by sequentially
clicking the 4 squares B1, B2, B3, C3. This inconvenient approach would also
lack the support of clicking a piece and have the squares it can move to
highlighted. An automaton would be useful if we had decided to use backtracking
to feed it with the set of all possible input streams. However, this approach is 
not serious, because of the infinite possibilities of input streams. 

\subsubsection{Actual implementation}
The idea of a pattern match is explained in \secref{sec:patterns}. In the
implementation, a pattern matching method takes a pattern, a game object, and a
position as input and then returns either true or false, depending on how the
pattern complies with the game objects (board, squares and pieces) relative to
the input position.

To aid the understanding of how pattern matching is implemented, this
small example is introduced before the full implementation, not using
any specific board layout:

\begin{quote}
When evaluating a pattern, a single branch is created containing the input
coordinate. A branch can be seen as a thing that ``digests'' the pattern
sequentially and moves around on the board accordingly. The branch is the thing
verifying that the pattern complies with board set up. For instance, given the
pattern \texttt{/n | w empty/} and the start position B2, one branch starts on
B2, meets the \texttt{|}-operator, and then splits into two branches. One branch
moves one square north, the other moves one square west. The two branches are
then united to a single branch containing the set of coordinates \{B3, A2\} The
next digested part of the pattern is the \texttt{empty} keyword. The
\texttt{empty} keyword causes all coordinates in the current branch to be
removed if the square on the board on that coordinate is not empty.  
\end{quote}

The pattern is now fully digested, and if the current branch still contains any
coordinates, it means that it was somehow possible to make a route from the
starting position that fully complied with the pattern, thus the pattern
matching returns true. If the branch did not contain any coordinates after
digesting the entire pattern, this means that it is in no way possible to choose
a branch which complied with the pattern, then the pattern match returns false.

In our full implementation of how a pattern is matched, these notations are
used:

\begin{dlist}
  \item \texttt{B} : a branch containing a set of coordinates
  \item \texttt{p} : a pattern
  \item \texttt{c} : a coordinate
  \item \texttt{d} : a direction, e.g. n (\textit{north}) or sw
    (\textit{south-west})
  \item \texttt{clone(p)} : returns an exact clone of \texttt{p}
  \item \texttt{evaluate(p, B)} : modifies the branch \texttt{B} in a way
    depending on the value of \texttt{p}
  \item \texttt{union(B$_1$, B$_2$)} : returns \texttt{B$_1$} $=$ \texttt{B$_1$} $\cup$
    \texttt{B$_2$}
    %adds all coordinates in \texttt{B$_2$} to
    %\texttt{B$_1$} if they were not already contained in \texttt{B$_1$}
  \item \texttt{concat(p, c)} : returns $\underbrace{\texttt{p p} \ldots
    \texttt{p}}_{\texttt{c}\text{ times}}$
\end{dlist}

The full implementation of a pattern match is explained in the following. When
checking if a pattern \texttt{p} matches on a coordinate \texttt{c} given the game object
\texttt{game}, this is what happens: 

\begin{quote}
  A new branch \texttt{B} is created, containing the input coordinate
  \texttt{c}.  \texttt{evaluate(p, B)} is called, and when the function returns,
  it is checked that if \texttt{B} contains any coordinates. If it does the
  pattern check returns true, and false otherwise.  
\end{quote}

The \texttt{evaluate(p, B)} function depends on the composition of \texttt{p} the
pseudocode for its implementation can be seen by \lstref{lst:patternalg}.

\lstinputlisting[caption={\emph{Pseudocode of how a pattern is evaluated on a
branch.}}, label={lst:patternalg}, language=Java]{listings/patternalg.pseudo}

\subsubsection{Visualisation of pattern algorithm}
\label{sec:vispatternalg}

The algorithm in \lstref{lst:patternalg} is used in \figref{fig:patternalg1} and
\figref{fig:patternalg2} to visualise how the algorithm works. The patterns will be
executed on the board in \figref{fig:patternboard2}.

\fig[scale=1.5]{patternboard2}{A possible board set up.}

The execution of the algorithm trying to match the pattern \texttt{/s? w* empty
n !empty/} on the square D3, can be seen in \figref{patternalg1}. 
The board set up used is that depicted in \figref{fig:patternboard}.

\fig[scale=0.35]{patternalg1}{Pattern matching of \texttt{/s? w* empty n
!empty/} on the square D3.}

The execution of the algorithm trying to match the pattern \texttt{/n|w n|w
!empty/} on the square C2 can be seen in \figref{patternalg2}. The board set up 
used is the one depicted in \figref{fig:patternboard}.
The two branches created when meeting a \texttt{|}-operator are merged again shortly after.
Notice how this increases efficiency, as the two red coordinates (B3) are merged
into a single branch before trying to match the successive pattern values.

\fig[scale=0.35]{patternalg2}{Pattern matching of \texttt{/n|w n|w !empty/} on the square C2.}

\subsection{Evaluation of interpreter}
We have implemented a complete interpreter with semantics for every single node
type, allowing us to explore and demonstrate every feature of \productname{}
without many limits.

Under development, we have kept flexibility in mind, allowing us to easily add
new base values and extend and maintain the feature set and semantics of our
language, without having to change any existing code. If we wanted to add an
addition operation between coordinates, it would only be a matter of adding a few lines
of code to the coordinate value class.

It is obviously not the fastest implementation of an interpreter, but we don't
see that as a hindrance, because speed is not what we're after.

There are a few optimisations that can be taken into account when writing an
interpreter to make it run faster, such as detecting tail recursion. Since
\productname{} has no loop-constructs, recursive functions are the only way to
repeatedly run through some code.

Patterns are also a very important and central feature to our language,
requiring an almost non-deterministic implementation, again hurting
performance. A restriction with patterns is that they only work on
grid-formed boards.
