\section{Abstract node types}
\label{sec:ant}

This section illustrates how we have chosen to implement the grammar described in
\secref{sec:grammar} into abstract syntax trees (ASTs). 
We have split every program part into their own subsections with an abstract
node type (ANT) that presents the program parts construction when it is parsed into an
AST. Each node type corresponds to a production in the grammar. These ANTs can
then be combined to form the AST when some piece of code has been parsed.

Firstly, the section begins with a description of how an AST differs from a parse tree 
to make this clear to the reader.

When a piece of code is parsed by a parser that understands the specific programming 
language, the output of the parser will be an AST which consists of the abstract node 
types of each program part. The difference between an AST and a parse tree is that a 
parse tree contains every detail of the input code. A parse tree includes for instance
the parentheses and keywords where an AST does not contain anything other than the 
abstract node types.\cite{parsevsast}

Now, the section is divided into three subsections. First we present the actual
parts of a program structure. Then we present which expressions the language
consists of. Finally, we present the different patterns.

\subsection{Program structure}
The following subsections present the structure of programs. The sections are 
structured as follows:

\begin{dlist}
  \item Program
  \item Definition
  \item Constant definition
  \item Type definition
  \item Type body and member definition
  \item Abstract definition
  \item Variable list
\end{dlist}

\subsubsection{Program}
Every program written in \productname{} begins with an abstract node type which 
we call ``program'' that consists of either zero, one, or more definitions. The 
production for this rule is as follows:

\begin{ebnf}
\grule{program}{\grep{definition}}
\end{ebnf}

It is from this production each and every program is derived from. The ANT for 
this production is illustrated in \figref{ast:program}.

\input{content/implementation/abstractnodetypes/program}

Figure \ref{ast:program} consists of one root which is called ``Program'' and
this root can have zero, one, or more children, called ``Definition''. The
children are optional because the production says that a program can consist of
either zero, one, or more of these definitions. We illustrate this choice by
making the connecting edges dashed from the parent node. Between these two child
nodes there are three dots ($\cdots$) which illustrate that it is possible to
have more of these nodes following each other.

This means that a program is legal if it does not contain anything at all.

\subsection{Expressions}
The following nine subsections present the different expressions in
\productname{}. The sections are structured as follows:

\begin{dlist}
  \item Operations with precedence and negation
  \item Element
  \item Member access
  \item Call sequence
  \item Assignment
  \item If expression
  \item Lambda expression
  \item List
  \item No-operator
\end{dlist}

\subsubsection{Operations with precedence and negation}
In this section we introduce the five different groupings of operations such as
logical operators, equality operators, etc., and finally we present the
production called negation. We illustrate the five groupings of operators but we
have omitted the negation node, because it is merely a root with one child. The
following grammar presents the productions for the different operations:

\begin{ebnf}
\grule{lo\_sequence}{eq\_sequence \gcat \grep{\ggrp{\gter{and} \gor \gter{or}} \gcat eq\_sequence}}
\grule{eq\_sequence}{cm\_sequence \gcat \grep{\ggrp{\gter{==} \gor \gter{!=}} \gcat cm\_sequence}}
\grule{cm\_sequence}{as\_sequence \gcat \grep{\ggrp{\gter{<} \gor \gter{>} \gor \gter{<=} \gor \gter{>=}} \gcat as\_sequence}}
\grule{as\_sequence}{md\_sequence \gcat \grep{\ggrp{\gter{+} \gor \gter{-}} \gcat md\_sequence}}
\grule{md\_sequence}{negation \gcat \grep{\ggrp{\gter{*} \gor \gter{/} \gor{\%}} \gcat negation}}
\end{ebnf}

The meaning of these different groupings of operators have been described in
\secref{sec:grammar}. To refresh the readers memory, the sequences are
intentionally placed in this specific order to ensure the correct precedence for
these operators.

Since the productions look a lot like each other we will only illustrate an
abstract ANT which shows how we have implemented the different operations.
Figure \ref{ast:operation} shows this.

\input{content/implementation/abstractnodetypes/operation}

Figure \ref{ast:operation} illustrates that the ANT for each production, with
the left-hand side (LHS) of the production as the root, will only be constructed
if there is at least two of the right-hand sides (RHS) with one operator between
them. This means that the sequence should for instance look like the following:

\begin{ebnf}
\grule{lo\_sequence}{eq\_sequence \gcat \gter{and} \gcat eq\_sequence}
\end{ebnf}

So, in the above example the RHS is $eq\_sequence$ and the operator is
$\gter{and}$. In \figref{ast:operation} we do not show the operators, which can
make it a bit cryptic to look at and understand. If there is only one RHS then
the node is not constructed but the next production will be evaluated. Otherwise
the AST would end up with many single-child nodes. This bad implementation is 
illustrated in \figref{ast:badexample}.

\input{content/implementation/abstractnodetypes/badexample}

Figure \ref{ast:badexample} illustrates very clearly that the AST quickly would
end up with mant single child nodes. If we do not expect two RHS then We will 
end up with a long list, which is not necessary and it will just make it less 
efficient to read the AST. With our implementation we will have a more efficient 
and more compact AST.

The grammar specified earlier in this section presented that the last operation
($md\_sequence$) consists of negations and the choice to add an operator between
negations. The negation production can be an element or begin with the \gter{-}
symbol followed by another negation.
The following productions present the grammar for the negation expression:

\begin{ebnf}
\grule{negation}{element}
\galt{\gter{-} \gcat negation}
\end{ebnf}

This production is not illustrated with any ANT.

\subsubsection{Assignment}
The following grammar rule specifies the production of an assignment in
\productname{}:

\begin{ebnf}
\grule{assignment}{\gter{let} \gcat variable \gcat \gter{=} \gcat expression \gcat \grep{\gter{,} \gcat variable \gcat \gter{=} \gcat expression} \gcat \gter{in} \gcat expression}
\end{ebnf}

The production specifies that any assignment must begin with the keyword
\gter{let} and end with the keyword \gter{in} followed by an expression. In
between these beginning and ending keywords, the production consists of at least
one sequence of a variable followed by an assignment-operator followed by an
expression. The production specifies that it is possible to have zero, one, or
more of these variable-expression pairs (comma separated) following the first
pair.

\input{content/implementation/abstractnodetypes/assign}

Figure \ref{ast:assignment} illustrates this with an ANT that omits the
keywords, commas and the assignment-operators, which can make it rather complex
to look at. The figure actually states that an assignment consists of variables
and expression where an expression can be many different things, including
another assignment. So, this means that it is possible to have assignments
nested within each other. 

We have chosen to implement the comma separated nodes as new assignment nodes
which has two nodes that are not optioanl. These nested assignments are
connected to the parent with dashed edges which mean that they are optional and
it is possible to have zero, one, or more of these following each other.