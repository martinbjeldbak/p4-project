\section{Abstract node types}
\label{sec:ant}

Abstractions are the interpreter's or compiler's internal representation of a program. It is represented as an abstract syntax tree which is a series of nodes and leaves connected, forming a so-called tree.%

This section covers all aspects of our abstract syntax tree (AST), and it begins with a description of how an AST differs from a parse tree. 
The grammar specifications are specified in \secref{sec:grammar}. In this section each program part is presented individually with an AST within its respective subsection.%

When a piece of code is parsed by a parser that understands the specific programming language, the output of the parser will be a parse tree which corresponds to the abstract syntax of each program part. The difference between an AST and a parse tree is that a parse tree contains every detail of the source code. A parse tree includes for instance the parentheses and keywords where an AST does not contain anything other than the abstract node types (function definition, game declaration, expression etc.).%

\subsection{Program}%
Every program written in \productname{} begins with an abstract node type which we call ``program'' that consists of either zero or more function definitions followed by a single game declaration. The production for this rule is a follows:%

\begin{ebnf}%
\grule{program}{\grep{function\_def} \gcat game\_decl}%
\end{ebnf}%

It is from this production each and every program is derived from. The AST for this abstract node type is illustrated in \figref{ast:program}.%

\input{content/implementation/abstractnodetypes/program}%

Figure \ref{ast:program} consists of one root which is called ``Program'' and this root has three children, two called ``Function definition'' and one called ``Game declaration''. The nodes named ``Function definition'' are optional because the production says that a program can begin with either zero or more of these abstract node types. The AST illustrates this by making the connecting lines dashed. Within these two nodes there are three dots ($\cdots$) which illustrate that it is possible to have more of these abstract node types following each other.%

This means that a program can begin with either a function or a game declaration. The following section will illustrate the abstract node type of a function definition which is part of the program abstract node type.%

\subsection{Function definition}%
Programmars have the opportunity of defining functions in their programs. The parser knows that the following piece of code is a function definition when it meets the keyword ``define'' and then the following three abstract node types are part of this definition. This is also evident in the grammar for a \textit{function\_def}:%

\begin{ebnf}%
\grule{function\_def}{\gter{define} \gcat function \gcat varlist \gcat expression}%
\end{ebnf}%

\input{content/implementation/abstractnodetypes/funcdef}%

Figure \ref{ast:funcdef} illustrates the AST for this production. The AST does not show the ``define'' keyword because it is not part of the abstraction. The keyword is there to make sure that the parser knows that the following production is a function definition and nothing else.%

The production defines that after the keyword ``define'' a function, a variable list, and an expression are followed in that specific order. If anything else is read then a syntax error will be thrown by the parser because then the input is not syntactically correct and does not correspond with the specification.%

It is clear that \figref{ast:funcdef} has three children from the root and these children are all drawn with solid lines. This means that they are not optional and must occur in that specific order. The \textit{expression} child is different from the others in its form and that it is written with an italic font. This is done to illustrate that an expression can be many different things.%

So, the AST in \figref{ast:funcdef} is different from the AST for the program abstract node type in that is has no optional children. The next section will cover the final part of the program which is the game declaration from which the rest of the program is derived from.%

\subsection{Function call}
\todo{write description}

\input{content/implementation/abstractnodetypes/funccall}

\subsection{Game declaration}%
The game declaration is the final part of the program abstract node type and it is from this abstract node type that the game is actually declared. The production for the game declaration is as follows:%

\begin{ebnf}%
\grule{game\_decl}{\gter{game} \gcat declaration\_struct}%
\end{ebnf}%

A function definition had a ``define'' keyword in front of every function defintion and the game declaration has another keyword - namely the ``game'' keyword. This makes sure that the parser is aware of the fact that the following declaration is the game declaration. The next production must be a declaration\_struct which is described in the next section.%

\input{content/implementation/abstractnodetypes/gamedecl}%

Figure \ref{ast:gamedecl} illustrates the AST for the game declaration. This is a rather simply AST with just one root and one child. The keyword in front of the declaration is not shown because it is not part of the tree. If anything else than a declaration struct is read by the parser a syntax error will be thrown indicating that the source code is not valid.%

\subsection{Declaration struct}%

The declaration struct consists of at least one declaration. The parser knows that the following is a declaration struct by ready the first symbol as being a left brace ( ``\{'' ) followed by one or more declarations and finalised with a right brace ( ``\}'' ). The following production specifies this:%

\begin{ebnf}%
\grule{declaration\_struct}{\gter{\{} \gcat declaration \gcat \grep{declaration} \gter{\}}}%
\end{ebnf}%

\input{content/implementation/abstractnodetypes/declstruct}%

Figure \ref{ast:declstruct} illustrates this by have one root with three children where the first child is connected with a solid line to the root followed by two similar children but with dashed lines specifying that the first declaration can be followed by zero or more declarations. The braces are not visible in the AST.%

\subsection{Declaration}%
The declaration is the last abstract node type which is described in this section that constitutes the game declaration. A declaration is identified by either a keyword or an identifier which will be followed by a structure. This is specified in the following production:%

\begin{ebnf}%
\grule{declaration}{\ggrp{keyword \gor identifier} \gcat structure}%
\end{ebnf}%

So, the parser reads either a keyword or a identifier and the following must be some kind of structure or else the parser will throw a syntax error.%

A structure can be many different things and \figref{ast:decl} illustrates this by encapsulating the child with the abstract node type of a structure in an ellipse formed box with italic font. This is similar to the expressions illustrated earlier.%

\input{content/implementation/abstractnodetypes/decl}%

So, this means that a program written in \productname{} will always have at least one structure because the declaration struct in \figref{ast:declstruct} specifies that at least one occurence of a declaration must be included.%

This finalises the abstract node types for the game declaration leaving the abstract node types for the function definitions which will be specified in the following sections.%

\subsection{Variable list}%

The function definition is constituted of a function followed by a variable list and an expression. The only part of a function definition that has an abstract node type is the variable list because for instance a function is not something that is specified in the grammar other than it can consist of any type of letter. The other part of a function definition is the expression which again can consist of many different things.%

A variable list can consist of variables be an empty list containing nothing. This is illustrated in the following grammar:%

\begin{ebnf}%
\grule{varlist}{\gter{[} \gcat \gopt{variable \gcat \grep{\gter{,} \gcat variable} \gcat \gopt{\gter{,} \gcat vars} \gor vars} \gcat \gter{]}}%
\end{ebnf}%

The production specifies that a variable list begins with an occurence of a left bracket ( ``['' ) and ends with an occurence of a right bracket ( ``]'' ). The brackets in between the outer bracket mean that the variables are optional. This means that a variable list can be empty.%

The last part of the production is a bit hard to read, but it says that if the list begins with one or more variable types then these variables can be followed by a comma and the variable argument which is a list of parameters. If there are no variable types then the last variable argument can be included. So, the production consists of two parts - one part containing two zero, one or more variables followed by an occurence of variable argument or just a single variable argument. This is due to the comma that must follow the last variable before a variable argument.%

\input{content/implementation/abstractnodetypes/variablelist}%

Figure \ref{ast:variablelist} illustrates this by having a root and three children with dashed lines from the root. But this is actually a bit misleading because of the optional parameters in the specification of the production. The production specifies that if the programmer does not want the list to be empty then at least one occurence of a variable must be present or a single variable argument. After the first variable it is possible to have zero or more variables following the first one and another optional variable argument. The easiest way to illustrate this is as it has been done in \figref{ast:variablelist}.%

\subsection{Assignment}%

An assignment is actually one of the many different abstract node types an expression can be. The following grammar rule specifies the production of an assignment in \productname{}:%

\begin{ebnf}%
\grule{assignment}{\gter{let} \gcat variable \gcat \gter{=} \gcat expression \gcat \grep{\gter{,} \gcat variable \gcat \gter{=} \gcat expression} \gcat \gter{in} \gcat expression}%
\end{ebnf}%

The production specifies that any assignment must begin with the keyword ``let'' and end with the keyword ``in'' followed by an expression. In between these beginning and ending keywords the production consists of at least one pair of a variable followed by an assignment-operator followed by an expression. The production specifies that it is possible to have zero or more of these variable-expression pairs (comma-separated) following the first pair.%

\input{content/implementation/abstractnodetypes/assign}%

Figure \ref{ast:assignment} illustrates this with an AST that omits the keywords, commas and the assignment-operators which can make it rather complex to look at. The figure actually states that an assignment consists of variables and expression where an expression can be many different things, including another assignment. So, this means that it is possible to have assignments nested within each other which is also illustrated in \figref{ast:assignment}. These nested assignments are connected to the root with dashed lines which means that they are optional and it is possible to have zero or more of these following each other.%

\subsection{If expression}%

The if expression is yet another expression as the name indicates. These expressions have one form and it is specified in the following production:%

\begin{ebnf}%
\grule{if\_expr}{\gter{if} \gcat expression \gcat \gter{then} \gcat expression \gcat \gter{else} \gcat expression}%
\end{ebnf}%

An if expression begins with the keyword ``if'' and ends with the keyword ``else'' followed by an expression. In between the beginning and the end the keyword ``then'' appears as a must in the if expression. It is for instance not possible to omit the ``else'' statement. The AST for this production is illustrated in \figref{ast:ifexpr} and consists of a root with three children which are expressions. The children are connected to the root with solid lines which means they cannot be omitted.%

\input{content/implementation/abstractnodetypes/ifexpr}%

\subsection{Lambda expression}%

The next expression is a lambda expression and is specified in the following production:%

\begin{ebnf}%
\grule{lambda\_expr}{\gter{\#} \gcat varlist \gcat \gter{=>} \gcat expression}%
\end{ebnf}%

Any lambda expression begins with the \# symbol which makes it clear for the parser that this is a lambda expression. A lambda expression consists of a variable list and an expression seperated by the $=>$ symbol.%

\input{content/implementation/abstractnodetypes/lambda}%

Figure \ref{ast:lambdaexpr} illustrates the AST for this expression. Because a lambda expression is an expression it is possible to have lambda expression inside other lambda expressions, so it is possible to nest these expressions.%

\subsection{List}%

We also have an abstract node type of the list element. Any list can be empty just like a variable list but instead of containing variables a list contains expressions. It can consist of either zero, one, or more expressions. The specification for the abstract node type is specified in the following production:%

\begin{ebnf}%
\grule{list}{\gter{[} \gcat \gopt{expression \gcat \grep{\gter{,} \gcat expression}} \gcat \gter{]}}%
\end{ebnf}%

This element begins and ends like a variable list with brackets with optional elements as the elements of the list. The AST for this production is illustrated in \figref{ast:list}.%

\input{content/implementation/abstractnodetypes/list}%

The AST in \figref{ast:list} lacks the same descpritiveness as the AST for the variable list does because of the optional parameters in the production. The AST illustrates that it is possible to have zero or more expressions in the list, but it is in fact not entirely correct. The correct statement is that it is possible to have either none or at least one expression in the list.%

\subsection{Pattern}%

The next element is a pattern which consists of a single pattern expression followed by zero or more pattern expressions. This is specified in the following production:%

\begin{ebnf}%
\grule{pattern}{pattern\_expr \gcat \grep{pattern\_expr}}%
\end{ebnf}%

This production is very straightforward, a pattern must contain at least one pattern expression. The AST for this production is illustrated in \figref{ast:pattern}. This AST has one solid line to the first pattern expression followed by two dashed lines to two other pattern expressions illustrating that these can occur zero or more times.%

\input{content/implementation/abstractnodetypes/pattern}%

\subsection{Pattern operators}%

\productname{} consists of three different pattern operators. We have an or-operator (\figref{ast:pattern-or}), a multiplier-operator (\figref{ast:pattern-mult}), and a not-operator (\figref{ast:pattern-not}).%

The or-operator derives a pattern value followed by a pattern expression that both can be many different things. This is why they are written in an italic font. This is illustrated in \figref{ast:pattern-or}.%

\input{content/implementation/abstractnodetypes/pattern-or}%

The multiplier-operator derives a single child namely a pattern value. This is illustrated in \figref{ast:pattern-mult}.%

\input{content/implementation/abstractnodetypes/pattern-mult}%

The not-operator also derives a single child namely a pattern check which is also written in an italic font within an ellipse formed box that indicates that it can be many different things. This is illustrated in \figref{ast:pattern-not}.%

\input{content/implementation/abstractnodetypes/pattern-not}%

\subsection{Not-operator}%

We also have a not-operator that has to do with expressions and not patterns. This operators AST is illustrated in \figref{ast:not} and derives an expression.%

\input{content/implementation/abstractnodetypes/not}%

\subsection{Operator}%

Furthermore \productname{} is able to handle arithmetic operators. The AST for operators is illustrated in \figref{ast:operator} and consists of an element followed by an expression.%

\input{content/implementation/abstractnodetypes/operator}%


\subsection{Expression and value node types}
\todo{write description and add trees etc.}

These are used throughout the production of source code written in \productname{}.

%\input{content/implementation/abstractnodetypes/identifiers}
%\input{content/implementation/abstractnodetypes/keywords}
%\input{content/implementation/abstractnodetypes/elements}
%\input{content/implementation/abstractnodetypes/expressions}
%\input{content/implementation/abstractnodetypes/literals}
%\input{content/implementation/abstractnodetypes/patternkeywords}
%\input{content/implementation/abstractnodetypes/variables}

%literals
%variables
%identifiers
%keywords
%pattern keywords
%expressions
%elements (this is a special keyword)
