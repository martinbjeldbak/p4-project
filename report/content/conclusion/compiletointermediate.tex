\subsection{Compilation to intermediate language, then further translation}
\label{sec:compiletointermediate}

In this project we decided to implement an interpreter for our programming
language. This decision was made on the basis of our analysis chapter
(\chapref{chap:analysis}) where we could conclude that this would be the optimal
approach for \productname{}, but it is possible to develop a compiler instead. In
this section we will explain what we should have done differently in terms of
the translation method. In \secref{sec:codegenerationandinterpretation} in the
analysis chapter we have analysed and discussed the differences between these
translation methods. Furthermore, in \secref{sec:intermediatelanguage} we
describe what an intermediate language is.

\todo{Rewrite}

%\subsubsection{Where are the differences between an interpreter and a compiler?}
%
%In \secref{sec:compilation} we introduced and explained the phases in the
%process of compilation, and with \figref{fig:compileroverview} we visualised
%these phases.
%
%The initial phases of a compiler are quite similar to the initial phases of an
%interpreter. For instance a compiler must also begin by scanning the source code
%followed by parsing the source code to get a stream of tokens and an abstract
%syntax tree, respectively. These steps are the same as we have described in
%\chapref{chap:implementation}. Furthermore, the step where we check if the
%different variables are visible in their respective scopes (scope checking) is
%also the same as described in \chapref{chap:implementation}. When the above
%mentioned phases have been run, then the compiler should compile the code to
%machine language or to an intermediate language.
%
%According to \figref{fig:compileroverview}, the result of the semantic
%analyser would be an intermediate language and then the code generator
%would generate machine code, which can then be executed. It is of course
%also possible to compile directly to machine language. Although, it is
%not the responsible choice to make because it kills opportunities to
%e.g.\ optimise the code and support multiple platforms, which would be
%possible with an intermediate language.
