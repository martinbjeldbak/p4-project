\subsection{Efficiency of pattern matching}
\label{sec:patternmatchingefficiency}
The design of pattern matching is undoubtedly a strong mechanism for describing moves, win condition, or any other check that depends on a particular pattern. The implementation of the pattern matching is highly inefficient. Consider the piece placed at the square D5 in \figref{fig:inefficientpatterns}. The blue piece can make the moves of a knight from a chess game. This can be specified in \productname{} with the pattern \texttt{/(n n e|w) | (s s e|w) | (w w n|s) | (e e n|w) this/}.

\fig[scale=0.3]{inefficientpatterns}{Pattern matching done on the 8 green squares will return true, given the moves of a knight and the blue square (D5) as input.}

To find the moves of the piece on D5, the pattern must be matched on all 64 squares given D5 as input. Those squares for which the pattern matching returns true are those squares the piece can move to. In \figref{fig:inefficientpatterns}, only 8 of those 64 checks performed are depicted. For a game of chess starting with 32 pieces, the pattern matching is actually done on all 64 squares \textbf{for all 32 pieces}. If we for simplicity assumed that each piece had 8 possible moves, the amount of work related to pattern checks for the first move in chess can be calculated to be $32 * 64 * 8 = 16384$.
Or more generally, $O(p * n * m * c)$, hvor $p$ = the number of pieces, $(n, m)$ = the size of the gridboard, and $c$ is the complexity of each move. It is easy to see how inefficient this approach is so lets now consider a better and even a more intuitive approach.

Consider the green piece placed at the square D5 in \figref{fig:efficientpatterns}. The 8 arrows shows the moves a knight can make. An easy way to find these squares is simply to start at the knight's square (D5), move two squares in an arbitrary direction and then one square in an orthogonal direction. This also seems like a quite efficient approach. This can implemented by modifying the pattern matching to take a square as input and return a list of squares that satisfy a given pattern. A pattern for the knights move could look like \texttt{\%this (n n e|w) | (s s e|w) | (w w n|s) | (e e n|w)\%}. Notice that the \% encapsulation is used to distinguish between this modified pattern matching mechanism and the actual pattern mechanism used in \productname{} which encapsulates a pattern using \\. Such a pattern matching done on D5 would return a list containing the green squares in \figref{fig:efficientpatterns}.
Compared to the pattern matching in \productname{}, this approach will have the complexity $O(p * c)$. Comparing to the previous example, the amount of work related to the first move of a game of chess would be $32 * 8 = 256 < 163840.$ The complexity here seems to not depend on the actual size of the gridboard, but this is only true in some cases, e.g. the moves of a knight. Considering the moves of a rook, the complexity of a move (the constant $c$) will depend on the size of the gridboard since this will increase the amount of squares a piece can slide to. Generally, patterns containing the pattern-value \texttt{*} or \texttt{+} will have a complexity depending on the size of the gridboard.

\fig[scale=0.3]{efficientpatterns}{The intuitive way to check the moves of a knight-piece in a chess game.}  