\chapter{Design}
\label{chap:design}

In this chapter we present the design of our programming language
(\productname{}). The abstract syntax of \productname{} will be presented in
\secref{sec:abstractsyntax} followed by the lexical structure of programs in
\secref{sec:lexicalstructure}. We also present the different expressions and
their grammar in \secref{sec:expressions} followed by the different definitions
and their grammar in \secref{sec:definitions}. Futhermore, we introduce patterns
in \secref{sec:patterns} which are very important in \productname{}.  Finally,
we present the predefined types and constants of \productname{} in
\secref{sec:predefined} where the standard and game environments are presented.

We begin this chapter by giving an example of a game implemented in
\productname{}:

\subsection*{Code example}
\label{codesample}

The following is an example of how a program is written in \productname{}. It is
an implementation of the board game Noughts and Crosses:

\codesample{noughtandcrosses.game}

\productname{} is a purely functional object-oriented programming language
designed explicitly for creating board games. We have developed \productname{}
by first brainstorming and writing a bunch of game implementations using a
``programming language'' which felt the most natural to us. This means that we 
were actually using the programming language before we had even constructed
it. We began by writing programs in the unfinished language to try to find out
how it should be built and what would be the easiest to write. 

In the following we will go through the \csref{noughtandcrosses.game}
and introduce some of the important concepts of \productname{}. These will be
further described in the rest of this chapter and in
\chapref{chap:implementation}.

The very first thing that is visible in \csref{noughtandcrosses.game} are the
two lines of comments. Comments are made with two forwardslashes. Comments are
described further in \secref{sec:comments}.

The next thing that happens is the declaration of a type \keyword{type}
\type{NacGame}[].  The types of \productname{} can be compared to classes as
seen in other object-oriented programming languages. The square brackets in
\productname{} are used to encapsulate parameters and to encapsulate the members
of lists.  \keyword{type} \type{NacGame}[] extends the super type \type{Game}
which is a built-in type in \productname{}. The \keyword{extends} keyword is
similar to the extends keyword of Java, and means the \type{NacGame}[] type
inherits members of the \type{Game} type.  \type{Game}'s constructor takes the
title of the game as input and it contains many useful constants and
functions which are described further in \secref{sec:predefined}. 

Constants and functions can be thought of as subprograms similar to methods.
They distinguish themselves from each other by the fact that constants cannot
take any parameters whereas functions can. Functions and constants are further
explained in \secref{sec:constantdefinitions}. One of the built-in constants is
\constant{players} which contains a list of players. In the code sample at line
four we see how the constant is defined. When a game, created in
\productname{}, is played, the turn is shifted between each of the players in
the list provided by the \constant{players} constant. This is true, unless the turn
order is specifically modified by the constant \constant{turnOrder}, which is
another built-in constant in the \type{Game} type. This however is not necessary
in a Noughts and Crosses game, since the turn order is very simple. For instance
if the first player must be able to make three turns before the second player
can make one, that would be defined in the \constant{turnOrder}.

Furthermore, \type{Game} contains the constant \constant{initialBoard} which in
this case is assigned a grid board (another built-in type that takes the height
and width of the board as parameters) of $3 \times 3$ squares. In other
programming languages the override keyword is used when implementing methods
from a super class but in \productname{} the override functionality
already exists in the define keyword. For instance in
\csref{noughtandcrosses.game} \constant{players} and \constant{initialBoard} are
overridden in line four and eight, respectively.

%A second type \type{NacPlayer}, is declared which extends the built-in
%\productname{} type \type{Player}. The \type{Player} type takes as input the name of
%the player and contains three important functions: \function{winCondition},

The next thing that is important in the code sample are the three functions: 
\function{winCondition}, \function{tieCondition} and \function{actions}. 

As the name indicates the \function{winCondition} checks if the current player
is in a winning state and returns a boolean value; true or false.
\function{winCondition} takes a game object as input. In Noughts and Crosses the
win condition is obtained if a player has three of his pieces in a row, in
either a vertical, horizontal or diagonal line. In \productname{} this is
specified by using what we call ``patterns'' which are explained in
\secref{sec:patterns}. Patterns begin and end with forwardslashes. A pattern for
\function{winCondition} can be seen through line 13 and 14.

The \function{tieCondition} function checks if a tie condition is obtained and
returns a boolean value; true or false. The tie condition is achieved whenever
the board is full. This is specified using the built-in function;
\function{isFull}. 

The last function \function{actions} also takes as input a game object and
contains a list of actions. In this case the only possible action is the
\function{addAction} function which makes it possible to add a piece to the
board of type \keyword{this}, which is the current player's piece type (crosses
or noughts), to an empty square on the board.

At first sight the code sample will look complicated. This is mostly due to the
overwhelming use of built-in functionality. This is however implemented to make
it easier and faster for programmers to write code in \productname{}, since they
don't have to implement all the functionality themselves.

\subsection*{Type system}

In \secref{sec:typesystemanalysis} we analysed the two main type system
approaches.  We chose the dynamic type system due to the fact that it increases
the writability of our programming language. As seen in the above code example
\secref{codesample} a Noughts and Crosses game can be created in only
approximately 20 lines of code.

The type system in \productname{} comprises a number of simple types, from which every other type
can be creted.

%dynamic (why?)
%inheritance
%members: constants/functions
%visibility (data)
%casting (super?)

\subsection*{Scope rules}

A scope is the context in which one or more variables or constants exist. In
\productname{} we for instance have different expressions with their own scopes
where their variables live and die. By this we mean that when the scope of the
expression ends, the variables within the scope cannot be accessed anymore.
These expressions with scopes will be defined in \secref{sec:expressions}.

Furthermore, it is important to know that \productname{} uses statical scoping.
Scope rules where described in \secref{sec:anal-scoperules}.

\input{content/design/abstractsyntax}
\input{content/design/lexicalstructure}
\input{content/design/expressions}
\input{content/design/definitions}
\input{content/design/patterns}
\input{content/design/predefined}

