\chapter{Requirements}
\label{chap:requirements}
This chapter presents the requirements for our programming language which we
have reached through our analysis. The requirements have been structured using a
method published by Stig Andersen\cite{requirementsGuide}. The requirements are
used throughout the development phases and requirements are added as the project
moves along and new challenges arise. 

%The purpose of a requirements specification is to make sure that the final
%product is able to do what is was intended to do and meets the specified
%requirements. 

The following list of requirements is mainly useful for us as designers to make
sure that the solution meets some requirements which express what the
programming language must/can/should contain. The list does not tell us we wish
accomplish this goal.

The requirements specification consists of three main points: functional
requirements, non-functional requirements and solution goals. Functional
requirements define what the final system should be able to do. Non-functional
requirements define different constraints and boundaries for the entire project.
Lastly, solution goals are overall requirements that help the project group
define the correct solution\cite{requirementsGuide}.

Every requirement has been given a number so that it is possible later in the
report to reference each requirement. This is for instance useful when we must
conclude on our work at the end of the project.

%Besvar spørgsmålet: “hvorfor?” for hvert krav
%Prioritere krav ved hjælp af MoSCoW (Must have, should have, could have,
%won’t have)

\paragraph*{Functional requirements:}
\begin{enumerate}[noitemsep]
  \item The programming language will be used to program board games
  \begin{nlist}
    \item It must be possible to implement Chess, including the special rules of
      Chess
  \end{nlist}
  \item It must be possible to define what pieces the game consists of
  \item It must be possible to define which pieces a specific player controls
  \item It must be possible to define the possible squares a piece can be moved
    to
  \item It must be possible to represent list structures
  \begin{nlist}
    \item It must be possible to perform list unions
    \item It must be possible to perform list intersections
  \end{nlist}
  \item It must be possible to use the language's built-in functions to do the
    following:
  \begin{nlist}
    \item Determine if a square is empty
    \item Determine if a square is occupied, and by who
    \item Check a condition for all objects in a collection
    \item Find all squares that match a specific pattern
    \item Concatenate lists
    \item Perform a lambda expression on each element in a list
    \item Move a piece to a square
    \item Capture the old piece on a specific square while moving a new piece to
      the same square
    \item Return which players turn it is
    \item Check if the current move about to be made for a piece is the first
      move made by that piece
  \end{nlist}
  \item It must be possible to determine which legal moves a player has
  \item It must be possible to define winning conditions
  \item It must be possible to define draw conditions
  \item It must be possible to perform integer arithmetic
  \begin{nlist}
    \item Addition, subtraction, multiplication, and division
    \item The programming language must have boolean operators
    \item The programming language must have comparison operators
  \end{nlist}
  \item It must be possible to perform string concatenation
  \item No function nor expression may produce side effects
  \item There must be an action type that handles game state changes
  \item It must be possible to create lambda expressions
  \item It must be possible to declare functions
  \item It must be possible to reference functions
  \begin{nlist}
    \item Functions must be first-class citizens
    \item It must be possible to call functions
  \end{nlist}
  \item It must be possible to non-destructively assign any value to variables
  \item The created board games must be playable in a graphical simulator
  \item The simulator must be able to remember move history
  \begin{nlist}
    \item It must be possible to undo/redo moves
    \item It must be possible to save the move history
    \begin{nlist}
      \item It must be possible to start a game from a saved move history
    \end{nlist}
  \item It must be possible to play over a network
  \end{nlist}
\end{enumerate}

The list of requirements also has \textbf{non-functional requirements}, which is
split into two topics -- performance limitations and project limitations.

\paragraph*{Performance limitations:}
\begin{enumerate}[noitemsep,resume]
% How do we follow up on the requirement below?
  \item It must be easy to learn how to program in the programming language
  \item The programmer must be able to implement board games with relatively few
    lines of code
  \item The programming language must not be an extension of another programming
    language
  \item It must be possible to have an arbitrary number of players
  \item The source code of a single board game must be written in one file
  \item The programming language must be formally defined
  \item The programming language will be interpreted (not compiled)
\end{enumerate}

\paragraph*{Project limitations:}
\begin{enumerate}[noitemsep,resume]
  \item The programming language must be functional and operable no later than
    $29$th of May, $2013$
  \item The group has approximately $20$ hours per week to work on the project
  \item The project is limited by the group members' skill in the design and
    development of programming languages
  \item The project (and hence the programming language) must have a catchy name
    and logo
\end{enumerate}

\paragraph*{Solution goals:}
\begin{enumerate}[noitemsep,resume]
  \item The programming language must make it easy and quick for programmers to
    develop board games
  \item The board games must be playable on different operating systems
\end{enumerate}


%not a requirement to print anything.
We have listed requirements and limitations for this project. The requirements
do not specify that the programming language must be able to perform I/O
actions. This means that it is not a must that it is possible to do this.

%no side effects - no global variables
An interesting requirement is that no functions can produce side effects which
means that there cannot be any global variables. A side effect can happen when a
global variable is manipulated in a function while the same global variable
might be used outside the manipulating function. 

Another thing about functions is that they must be first-class citizens, which
means that they can be passed as arguments to other functions or as a return
value.
