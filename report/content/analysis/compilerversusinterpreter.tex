\section{Compiler versus interpreter}

Along with the design of the programming language \productname{}, we also want to make it possible for programmers who write games in \productname{} to actually play them afterwards. There are a number of ways we can make that happen. A \productname{}-compiler can be written that makes it possible to compile and play the games afterwards. The compiler approach will result in an executable file that is platform dependant. The platform targeted could also be a virtual machine, e.g. Java Virtual Machine thus a greater platform independence is achieved. Since \productname{} is a programming language optimised for writing board games, some design decisions have already been taken by the developers, which a \productname{}-programmer cannot change. For example, how a move is made physically by drag- and drop with the mouse or by using some keyboard short-cuts, the look of menu items, the sounds when moving a piece and features such as opportunity to undo moves and networked multiplayer games. If we, the developers of \productname{} later on wants to implement networked multiplaying or other features, all games previously written in \productname{} would have to be recompiled using a new compiler to support the added features. Doing so is not always easy since a game developer can have released his games on numerous distribution websites. Some websites may also have further distributed the games to 3rd party websites, which makes updating a game very hard thus releasing a new version of the game may be considered instead. We consider it important that we always can improve games with new and better features without forcing programmers to recompile all their games. 
An approach that allows us to do so is by using an interpreter instead of a compiler. By interpreting \productname{} source code at runtime or maybe some intermediate language derived there from, games (which is practically source code) can be left unmodified, while a modified interpreter allows new features to be implemented into already released \productname{}-games.
One disadvantage of using an interpreter is the speed of which code is executed. It definitely decreases. A compiler produces machine code through one or more compilation processes, while the interpreter interprets a language at runtime. For a graphic heavy game like a first person shooter, it could be argued that raising the frame rate was important enough to favour the compiler approach. For a board game and the computations involved, we think the hardware in modern computers today will be sufficient to make it impossible to feel a difference whether we choose to compile or interpret. However, if we were to include some artificial intelligence for playing \productname{}-games, a compiler approach would improve the speed of code execution and thereby the strength of the AI-player. The AI-part can however be separated from the interpreter. When summing up we found the arguments for creating an interpreter to be the most convincing. We therefore choose to develop an interpreter for \productname{}.
