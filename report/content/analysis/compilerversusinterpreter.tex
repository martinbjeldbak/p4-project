\section{Compiler versus interpreter}

Along with the design of the programming language \productname{}, we also want to make it possible to play a game once it has been written in \productname{}. There are a number of ways in which we can make people capable of playing the games written in \productname{}. A compiler can be written, that makes it possible to compile \productname{}-games and play them afterwards. The compiler approach will result in an executable file that is platform dependant. The platform targeted could also be a virtual machine, e.g. Java Virtual Machine thus a greater platform independence is achieved. Since \productname{} is a programming language optimised for writing board games, some design decisions has already been taken, which a \productname{}-programmer cannot change. For example, how a move is made by drag and dropping a piece, the look of menu items, the sounds when moving a piece and features such as undo moves and networked multiplayer games. If we, the developers of \productname{} later on wanted to implement networked multiplaying, all games previously written in \productname{} would have to be recompiled using a new compiler that supports the added features. Doing so is not always easy since a game developer can have released his games on numerous websites, that typically distributes games to 3rd part websites. Adding the new features would typically require releasing a new version of the game instead of modifying the previous. We consider it important that we always can improve games with new and better features without forcing programmers to recompile all their games. 
An approach that allows us to do this is by using an interpreter instead of a compiler. By interpreting \productname{} source code at runtime or maybe some intermediate language derived there from, games (which is practically source code) can be left unmodified, while a modified interpreter allows new features to be implemented into already released \productname{}-games.
One disadvantage of using a compiler is the speed of which code is executed, which decreases. A compiler produces machine code through one or more compilation processes, while the interpreter interprets a language at runtime. For a graphic heavy game like a first person shooter, it could be argued that raising the frame rate was important enough to favour the compiler approach. For a board game and the computations involved, we think the hardware in modern computers today will be sufficient to make it impossible to feel a difference whether we choose one approach over the other. However, if we were to include some artificial intelligence for playing \productname{}-games, a compiler approach would improve the speed of code execution and thereby the strength of the AI-player. The AI-part can however be separated from the interpreter. When summing up we found the arguments for creating an interpreter to be the most convincing. We therefore choose to develop an interpreter for \productname{}.
