\section{Compiler versus interpreter}

Along with the design of the programing language \productname{}, we also want to make it possible to play a game once it has been written in \productname{}. There are a number of ways in which we can make people capable of playing the games written in \productname{}. Some of the options can be seen here as well as advantages of each:
\begin{itemize}
\item A \productname{} compiler that targets a specific system arcitechture and creates a playable game written in machine code
	\begin{itemize}
	\item Pros
		\begin{itemize}	
		\item Gives us full control over what machine code that will be produced.
		\end{itemize}
	\item Cons
		\begin{itemize}	
		\item For every machine arcitecthure we want the \productname{} programming language to be able to compile to, we must make a compiler that targets that specific machine arcitecthure.
		\end{itemize}
	\end{itemize}
\item A \productname{} compiler that compiles to an intermediate language, for instance C.
	\begin{itemize}
	\item Pros
		\begin{itemize}
		\item Lets \productname{} target many different platforms if the compiler compiles to a language that does so, C e.g.
		\end{itemize}
	\end{itemize}
\item An interpreter that acts as a virtual machine for simulating all games written in.
	\begin{itemize}
	\item Pros
		\begin{itemize}
		\item We can at all times modify our interpreter, for instance if we want to include new skins for the board, allow networked multiplayer, e.g, without people need to recompile their games. 
		\item The interpreter can be written in a language like C that targets many different platforms.
		\end{itemize}
	\end{itemize}
\end{itemize}