\subsection{Constructing a parser}
\label{sec:ana-parsers}
The principle of generating parsers is very systematic and therefore there are different automated tools to generate parsers for a specific grammar that meets some standards. A grammar must for instance not be ambiguous otherwise the tools cannot make a distinct parser for the grammar. A grammar is ambiguous if a string can be generated with more than one parse tree. We start by taking a look at the constructing of a handwritten parser. Then we take a look a two different parser generators that produce different parsers. Finally we sum up the pros and cons of the analysis on handwritten and generated parsers. 

\subsection{Handwritten parsers}
\label{sec:handparser}
Why would you write a parser on your own when you have automated tools for this job? If we were to construct our own handwritten parser, and not use the tools alreadt built for this, it would be so that we would gain a greater understanding of how these parsers work. How are they constructed? What kind of errors could occur when trying to develop a parser? One of the best ways to learn is to fail - learn from the mistakes and correct them. But this is also a pain in the neck if a lot of errors are popping up and the person trying to get the job done does not have the expertise to resolve the errors and find a solution.

So we would gain experience and probably learn a lot by writing our own parser - but what are the pitfalls of taking on this task? First of all we could be stumbling upon many errors in the code. These errors must be solved before the parser can be finished. Therefore the construction of the parser will be time-consuming. So we will be gaining knowledge about the process but it will take a lot of time compared to an automatic generator.

Programming languages evolve and their grammar can change. When this is the case the parsers must be maintained so that they still output the correct result. When we have generated a parser by hand this task will be time-consuming because we must search through the code of the parser and tweak it so it will be correct again. Whenever we work on tweaking existing code we are most likely going to run into new errors that need to be resolved. 

This brings us to the topic of how reliable our handwritten parsers are compared to the generated parsers. So far we have discussed that the produced code for a handwritten parser will be error-prone so this will naturally bring us to conclude that this code must be less reliable than the automated generators produced code. This is a big con because we have to be able to rely on the output of the parser. To check the validity of a parser, it can be given a set of inputs that are almost in its language but contains a small error, which must cause the parser to reject the inputs. Additionally, a set of inputs can also be constructed, which is \textbf{in} the language, hence the parser must build a correct abstract syntax tree. For each input, the AST outputted by the handwritten parser can be compared to the one outputted by the parse generator tool. If the parse generator has not been constructed yet, one can choose to manually write the expected AST in XML, which most languages / programming frameworks support, using the grammar as reference.

\subsection{Generated parsers}
\label{sec:ana-genparser}
There are quite a few automated parser generaters (compiler compilers). To construct af parser with a generator the developer must input the grammar into the generator, and it will output a parser for that specific grammar. This can be a bit different from software to software but the grammar is often expressed using the Extended Backus Naur Form (EBNF) and the output parser will be produced in the language the generator is meant to output. We take a short look at SableCC and JavaCC in the following two section that both produce Java source code.

What differences are there between a handwritten and a generated parser? We need a grammar in both methods so what is the advantages of a generated parser? First of all, it takes less time to construct the parser because once we have a grammar we can input it in the generator and it will automatically generate the parser for us. Before we can use the software we have to figure out how to use it but this is not a complicated process. For every software there is some kind of tutorial on how to use the software.

The software that generate the parsers have been under development for quite a while and therefore the developers are using efficient algorithms to implement the parsers. This means that the parser we construct by hand will not be as fast and reliable as the ones generated by the software - unless the programmer is very experienced with a wide knowledge base about this subject. So the generated parser is most-likely more efficient.

Maintenance of the parser is also much easier because everything is machine-produced and can easily be changed to correspond witht he new grammar if the grammar has been changed.

There are different methods for constructing parsers. We have top-down parsers, where the parse trees are built from the root (the top) to the bottom, and bottom-up parsers, where the parse trees are built from the bottom to the root. Different grammars have different limitations and  the different types of parsers work on specific grammars. We will shortly discuss this in the following sections.

\subsubsection{SableCC, a bottom-up parser}
\label{sec:ana-sablecc}
SableCC is a bottom-up parser generator that generates LALR(1) parsers. This generator runs on the Java-platform and produces object-oriented code with clearly seperated machine-generated code and handwritten code. This contributes to the simplification and ease of maintaining the code.\cite[pp. 11]{sableccdoc}

The following is a list of advantages that LR parsers have:\cite[pp. 193]{sebesta2013} \todo{kontroller sidetal! afsnit 4.5.3}


The only disadvantage a LR parser has is that it is verey difficult to produce by hand. We have the automated generators to solve this disadvantage.

\subsubsection{JavaCC, a top-down parser}
\label{sec:ana-javacc}
JavaCC is a top-down parser generator that generetes LL(k) parsers. As the name of the parser generator it also produces the output code as Java source code.\cite{wiki-javacc}

\subsection{Summary}
\label{sec:ana-parsersum}
By reading the above section about handwritten parser we can conclude the following advantages by handwriting a parser:

\begin{dlist}
\item Gain experience in constructing parsers
\item Gain a better understanding of how parsers work
\end{dlist}

We will be gaining a lot of experience by writing a parser by hand and solving the problems that arise along the way. But there are quite a few disadvantages accompanied with handwriting a parser, and they are as follows.

\begin{dlist}
\item Can be error-prone
\item Can be time-consuming to construct
\item Time-consuming to maintain
\item Less reliable than generated parsers
\item Slower than generated parsers
\end{dlist}

We've summed up the advantages and disadvantages of handwritten parsers. Know we take a short look at the advantages of generated parsers. By reading the above section about the automatically generated parsers we can conclude the following advantages:

\begin{dlist}
\item Efficient
\item Reliable
\item Fast
\item Easy to maintain
\end{dlist}

These parsers will most-likely be more efficient and faster than handwritten parsers because they include efficient algorithms developed and maintained throughout the lifetime of the software. This also makes them more reliable than handwritten parsers because there will be much less errors in the process of constructing the parser.

This brings us towards a conclusion on handwritten and generated parsers. It is very clear that there are more benefits in using an automated generator to construct a parser. It is quite obvious that it will be much easier to reach our goal of constructing a parser. But we believe that it is very important that we try to gain experience and therefore we will be both handwriting a parser and using a generator as well.