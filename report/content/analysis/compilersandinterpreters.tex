\section{Compiler and interpreter}
Along with the design of the programming language \productname{}, we also want to make it possible for programmers who write games in \productname{} to actually play them afterwards. 
There are a number of ways we can make that happen. It can be translated to platform dependant machine instruction using a compiler, or it can be parsed and executed on-the-fly using an interpreter.

\subsection{Compilation}
With compilation, an executable would be created for a specific platform which contains all the code required to play the game. 
Since games have common aspects, a game engine containing all the common aspects such as user interface, AI and/or network play would most likely be written. 
This engine would then be included directly in the executable.

An obvious disadvantage is that the executable is platform dependant and it would therefore be necessary to develop a new compiler for each platform we want to support. 
On the other hand knowing the specific platform makes it possible to create optimized code which runs faster.

Instead of compiling to native machine code, it could be compiled to an intermediate format such as Java bytecode which is supported on many platforms.
While Java bytecode is interpreted and therefore slower, modern interpreters uses sophisticated methods such as Just-In-Time compilation (JIT) which recompiles it into native machine code. 
This process of course adds an overhead, however the speed differences are not that great anymore. \todo{ find some references and example numbers}

\subsection{Interpretation}
An interpreter takes the original source code directly to parse and execute it in one step.
This separates the game code from the forehand mentioned engine and requires the end user to get both the interpreter and the actual game.
Different games written in our language would then use the same copy of the interpreter, instead of having a copy of the engine for each executable. This separation will be further explored in \secref{subsec:engineseperation}.

The execution speed will however suffer and while techniques such as JIT exists to improve this, it is beyond the scope of this project. \todo{can we justify this?}

The execution speed is not critical however. 
Processors nowadays are fast and executing tasks such as calculating moves would most likely finish so fast that you wouldn't be able to notice the difference between a compiled and a interpreted version.
One task where speed does become important is artificial intelligence (AI), which would be used to create an virtual opponent controlled by the computer. 
The virtual opponent becomes smarter the more turns it can look ahead, however the computation complexity is high and a doubling of speed is quite noticeable when the time to make a move is reduced from 2 minutes to one.

An inherent consequence of interpretation is that the original source code is available for everyone which obtains the game. This can discourage developers which intends to sell their game, as it is easy for everyone obtaining a copy to make derivatives of it. Others will find it as an advantage as they can fix errors, add new gameplay elements or use it as a base for a completely new game.

\subsection{Separation of game and engine}
\label{subsec:engineseperation}
Keeping the game and the engine separated opens up for the possibility of changing the game engine while still being able to use the same game. 

One major advantage is that it is possible to update the engine and in result, update all your games.
An update which improves the graphics or add new features such as network support would work with older games instantly, without having to wait for the developer to update it.
If the developer no longer maintains the game, a updated version might never come out.

The disadvantage with this is however that the responsibility for maintaining compatibility is moved from the developer of the game to the developers of the engine. A game developer can simply change his program so it works with a new engine, however the engine developers would have to support games written for every version released.

\subsubsection{Compiled plug-in}
It is possible to achieve this using compilation too.
The game could be compiled to a plug-in, which the engine loads dynamically.

\subsection{Security}
Compiling makes it possible to create trojan horses, which are programs that appears to do something for the user, but which executes malicious actions behind the users back. 
Even if it is not possible to produce malicious code in \productname{}, code could be injected into the resulting executable.

With interpretation we define ourselves which actions exists and therefore can chose only to include actions which we know are safe. 
Even if we decide to allow certain questionable actions, since it is not executed directly on the CPU and instead goes through our interpreter, we can provide a sand-boxed environment which restricts the actions to only allow a safe subset. For example, we might provide access to the file system, but only allow file deletion in the games own directory.

fixing security holes with faster updates

interpretor increases codebase

\subsection{Intermediate format}
possible slight performance improvement

high-level vs low-level

package format, combining sound, images and code (possible also source code when requested)

\subsection{Summery}

