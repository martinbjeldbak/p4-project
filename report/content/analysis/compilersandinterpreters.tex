\section{Compiler and interpreter}
Along with the design of the programming language \productname{}, we also want to make it possible for programmers who write games in \productname{} to actually play them afterwards. 
There are a number of ways we can make that happen. It can be translated to platform dependant machine instruction using a compiler, or it can be parsed and executed on-the-fly using an interpreter.

\subsection{Compilation}
With compilation, an executable would be created for a specific platform which contains all the code required to play the game. 
Since games have common aspects, a game engine containing all the common aspects such as user interface, AI and/or network play would most likely be written. 
This engine would then be included directly in the executable.

An obvious disadvantage is that the executable is platform dependant and it would therefore be necessary to develop a new compiler for each platform we want to support. 
On the other hand knowing the specific platform makes it possible to create optimized code which runs faster.

Instead of compiling to native machine code, it could be compiled to an intermediate format such as Java bytecode which is supported on many platforms.
While Java bytecode is interpreted and therefore slower, modern interpreters uses sophisticated methods such as Just-In-Time compilation (JIT) which recompiles it into native machine code. 
This process of course adds an overhead, however the speed differences are not that great anymore\cite{java-speed}.

\subsection{Interpretation}
An interpreter takes the original source code directly to parse and execute it in one step.
This separates the game code from the forehand mentioned engine and requires the end user to get both the interpreter and the actual game.
Different games written in our language would then use the same copy of the interpreter, instead of having a copy of the engine for each executable. This separation will be further explored in \secref{subsec:engineseperation}.

The execution speed will however suffer and while techniques such as JIT exists to improve this, it is beyond the scope of this project. \todo{can we justify this?}

The execution speed is not critical however. 
Processors nowadays are fast and executing tasks such as calculating moves would most likely finish so fast that you wouldn't be able to notice the difference between a compiled and a interpreted version.
One task where speed does become important is artificial intelligence (AI), which would be used to create an virtual opponent controlled by the computer. 
The virtual opponent becomes smarter the more turns it can look ahead, however the computation complexity is high and a doubling of speed is quite noticeable when the time to make a move is reduced from 2 minutes to one.

An inherent consequence of interpretation is that the original source code is available for everyone which obtains the game. This can discourage developers which intends to sell their game, as it is easy for everyone obtaining a copy to make derivatives of it. Others will find it as an advantage as they can fix errors, add new gameplay elements or use it as a base for a completely new game.

\subsection{Separation of game and engine}
\label{subsec:engineseperation}
Keeping the game and the engine separated opens up for the possibility of changing the game engine while still being able to use the same game. 

One major advantage is that it is possible to update the engine and in result, update all your games.
An update which improves the graphics or add new features such as network support would work with older games instantly, without having to wait for the developer to update it.
If the developer no longer maintains the game, a updated version might never come out.

The disadvantage with this is however that the responsibility for maintaining compatibility is moved from the developer of the game to the developers of the engine. A game developer can simply change his program so it works with a new engine, however the engine developers would have to support games written for every version released.

\subsubsection{Compiled plug-in}
It is possible to achieve this using compilation too.
The game could be compiled to a plug-in, which the engine loads dynamically.

\subsection{Security}
When compiling to a native instruction set, we have access to every instruction on that platform, also potentially unsafe instructions.
Even though our language does not include features which makes use of those instructions, it is possible to use code injection on the compiled code to make it execute any code.
This way you could create a trojan horse, which appears to be a normal game but might do malicious actions in the background.
For example, it could randomly delete files from the users document folder each time he won.

With interpretation we define ourselves which instructions exists and therefore can chose only to include instructions which we know are safe.
Even if we decide to allow certain questionable actions, since it is not executed directly on the CPU and instead goes through our interpreter, we can provide a sand-boxed environment which restricts the actions to only allow a safe subset. 
For example, we might provide access to the file system, but only allow file deletion in the games own directory.

\subsection{Intermediate format}
A middle step between compiling and interpretation is to compile to a intermediate format which is then interpreted. 
The intermediate language could be more low-level which would make it possible to optimize the code for higher efficiency.

The intermediate format could be stored as an archive file which contains not only the code, but also sounds, images and other resources required to play the game.
This would allow for easy distribution of a game in \productname{}.
The source code would not be available like with a compiled game, however a package format could allow to optionally include the original source if the developer wants to share.

Using an intermediate format however means that you need to create a compiler, an interpreter and the intermediate language, which in turn is a significant larger amount of work.

\subsection{Summery}
A compiler can make faster code, however an interpreter allows us to fine-tune security considerations. 
Separating the game engine and game code gives a significant improvement for both methods.
Creating an intermediate language can give some advantages over a purely interpreted language, however it also requires more work to develop.
