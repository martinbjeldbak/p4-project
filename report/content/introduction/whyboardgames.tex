\subsection{Why board games?}
\label{whyboardgames}

%Board games have been played throughout almost all 
%of history, within different cultures, societies, 
%and countries. Backgammon is known to be at least 
%5,000 years old, and is still played today. Board 
%games can consist of a board, some player pieces or 
%tokens, a  deck of cards, and/or dice. The given 
%player or players follow a set of rules in an attempt 
%to achieve a goal. Strategy and luck are usually 
%involved in some form so playing the game more than 
%once is engaging and dynamic. Most board games only 
%involve one winner at the end of the game.

So what do board games have to do with designing,
defining, and implementing a programming language?
If you're able to describe how board games work
on a very generic and general level, it would
theoretically be possible to abstract away from
that to describe all games in general.
%; something that could be very beneficial for 
%game designers in many different ways.

If a language purely concentrates on allowing the
programmer (i.e. game designer) to express how his
game works, it would be quicker and easier to pick
up and develop shorter and more precise programs
rather than having to reimplement everything
from scratch in an already existing high-level
language. Furthermore, data structures and special
statements specifically designed to help define
board games would greatly increase the readability
and writability of such a program.

A language designed with board games in mind
would also allow the game designer to, relatively
quickly, explore new ideas for a board game
with a simple implementation. He/she could then
efficiently modify the code according to a new
rule or idea, and the implementation would stay
exactly the same. If the language also took
multiple platforms into account, it would open
up the possibility to run the same game across
multiple devices.

This could enable AI creation for the language
that understands the rules, so you can test an
early implementation of your game without the need
of other human players.

An example could be four-person chess. If you
already had an implementation of chess in the
programming language set up with a board and
separate rules for each piece, then it could be as
simple as changing the piece location and player
count (and maybe editing the rules for one or two
of the pieces so it's a little more fair) followed
by running the program again.

Programming languages exist to create programs that 
express algorithms to control the behaviour of machines.
Most board games, as we will demonstrate, have specific 
rules and exact winning conditions to follow, which can
be described to a very detailed degree.

Different categories of board games exist and board games 
can be placed into different genres, such as: strategy, 
alignment, chess variants, paper-and-pencil, territory, 
race, trivia, wargames, word games, and dozens of others. 
Obviously some games can overlap genres. Chess is an 
example of this. It is obviously a chess variant and is 
very strategy-heavy.

Before we begin to develop our programming language
we have to do some research about board games, the different 
programming paradigms, and then we will give an overview 
of what a compilers job really is, then we will present our 
findings about scanning and parsing methods, followed by 
a comparison of compilers and interpreters, and finally
we will define what a game simulator is and why we need one.
When the analysis is done we present our problem statement at
the end of this chapter.