\section{Types}
\label{sec:types}

\productname{} has support for the following types: Integer, String, Direction, Coordinate,
Function, Pattern, List and Action.

There is no $null$-type or $null$-value, since all expressions must have a value. This
is also evident in the definition of the $if$-expression in \secref{sec:grammar}, in that
all $if$-expressions must have the $else$-branch.

\subsection{Integer}
The integer-type in \productname{} represents a 32-bit integer.

An integer-value can be created using an integer-literal, such as \texttt{2155} or \texttt{0}.

\subsection{String}
The string-type represents a UTF-8 encoded string.

A string-value is created using a string-literal, such as \texttt{"Hello, World!"} or \texttt{""}.

\subsection{Direction}
The direction-type represents a direction on a game board. It works like a vector
in the sense that they can be combined to compute new directions. The basic directions
are \texttt{n}, \texttt{e}, \texttt{s} and \texttt{w} (north, east, south and west).
On a 2-dimensional grid (such as for chess) north is up, east is right, south is down and 
west is left.

The directions \texttt{ne}, \texttt{nw},
\texttt{se} and \texttt{sw} are also available, although these could also be produced
by combining the basic directions (e.g. \texttt{n + e = ne}). An example of a direction combination is the
expression \texttt{n + n + e} which produces
the direction shown in \figref{fig:direction_nne}. This direction could also be produced by
\texttt{n + ne} or \texttt{ne + n}.

\fig{direction_n}{The \texttt{n}-direction.}

\fig{direction_nne}{The \texttt{n + n + e}-direction.}

\subsection{Coordinate}
This type represents a position in a grid, i.e. on the game board. It is created with
a coordinate-literal, e.g. \texttt{A1} or \texttt{AH23}. The first part (the alphabetical part)
represents the column (or x-value), i.e. \texttt{A} means column $1$ and \texttt{AH} means
column $1 \cdot 26 + 8 = 34$. The second part (the numeric part) represents the row (or y-value).

\fig{coordinates}{All coordinates on an $8 \times 8$ board.}

\subsection{Function}
Functions in \productname{} are first-class citizens, meaning that they can be used as any
other value. A function name without a list of arguments results in a reference to that
function. Function references can be passed as arguments to other functions or as a return
value.

Another way to create function references, is to use anonymous functions in the form
of lambda expressions. A lambda expression is created by combining a list of input-variables
with an expression, like so:

\codesample{lambdaexpression.garry}

In the example above, a lambda expression is assigned to to \variable{max}-variable, before
being called as a function in line 2. The \texttt{\#}-symbol is used to mark the beginning
of a lambda expression. The scope rules of lambda expressions are further described in \secref{sec:scoping}
while the declaration of named functions is described in \secref{sec:functions}.

\subsection{Boolean}
Although there are no boolean constants (``true'' and ``false'') in \productname, the type still exists, since
boolean values can be returned by some expressions. Boolean values are also required in the condition of
if-expressions.

\subsection{Pattern}
A unique feature of \productname{} is patterns.
a pattern used for matching patterns on the board.

\subsection{List}
A list is an ordered collection of values. The same value may occur more than once. Lists are created using square brackets containing a comma separated list of elements. The empty list can be created with $\texttt{[]}$. Lists are important, and necessary when calling functions.

List values may be accessed by calling the list as if it was a function.
The following expression will return the element at offset 1 in the list
($5$):

\codesample{listaccess1.junta}

Ranges of elements can also be returned. For instance in the following
expression a new list is returned containing elements from offset 1 up
to and including offset 2 (the list $\texttt{["is", "a"]}$):

\codesample{listaccess2.junta}

\subsection{Identifier}
An identifier is a reference to a certain object. It always begins with an uppercase letter.
Consider for instance the \productname-implementation
of Noughts and Crosses. The implementation uses three identifiers; \identifier{Noughts},
\identifier{Crosses}, and \identifier{XOPiece}. An identifier doesn't have to be declared, and no matter
where it is used, it always refers to the same object. Two differently named identifiers can't refer
to the same object. Some uses of an identifier may add more identity to the object referred to by that
identifier. Consider for example the line:

\codesample{nncplayers.garry}

In this line, the objects referred to by \identifier{Noughts} and \identifier{Crosses}, are declared
to be players. This means that further on, when using \identifier{Noughts} and \identifier{Crosses},
they can only be used in contexts where a player-object is applicable.

The other identifier, \identifier{XOPiece}, is used as a name for the one type of piece in
Noughts and Crosses:

\codesample{nncpiece.garry}

This means that further on \identifier{XOPiece} will refer to that type of piece.


\subsection{Action}

Something about monads here...
