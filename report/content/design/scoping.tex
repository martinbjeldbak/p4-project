\section{Scoping}
\label{sec:scoping}

A scope is the context in which one or more variables exist.
There are three types of scopes in \productname{}. Function scopes, lambda scopes and
``let''-scopes.

\begin{dlist}
\item What is scoping?
\item Examples of static/lexical versus dynamic scoping
\item Why do we want to use dynamic scoping
\item What does that mean for \productname?
\end{dlist}

\subsection{Function scope}
Consider a function definition such as:

\codesample{functiondef.garry}

The variables \variable{a} and \variable{b} only exist within the function \function{max}.
When calling the function:

\codesample{functioncall.garry}

A new scope will be created and the values $5$ and $23$
are assigned to \variable{a} and \variable{b}, respectively.

Named functions (such as \function{max}) always exist in the global scope.

\subsection{Lambda expression scope}

When a lambda expression is created, a reference to the scope it was created
in is saved with it. This is known as a closure, and means that a lambda
expression may access variables outside of its own scope. The accessible
variables are the variables that were available at the time of the creation
of the lambda expression.

Consider the following example:

\codesample{closuredef.garry}

A function \function{getAdder}, which takes one argument (\variable{a}) and
returns a lambda expression, is defined. Notice how \variable{a} is used within
the lambda expression. This means that when the lambda expression is created, it
must remember the value of the variables that exist in the scope, in which it is
created. The use of the \function{getAdder}-function could look like this:

\codesample{closureuse.garry}

In the first line \function{getAdder} is called with the argument, $25$. A new scope, $A$,
is created, in which the variable \variable{a} is assigned the value $25$. Then the function
expression is evaluated, which results in a new lambda expression (with a reference to scope $A$).
This is returned and assigned to \variable{adder} in line 1 of the above example.

In the second line the \variable{adder} is called as a function, which means that a new scope, $B$,
is created, in which the variable \variable{b} is assigned the value $5$. The important part is
that $B$'s parent scope is set to $A$ (which is saved with the lambda expression). The expression
(the right side of the lambda expression) is then evaluated. First the \variable{a}-variable is
encountered. The interpreter first searches the $B$-scope for \variable{a}, and when unsuccessful,
searches the parent-scope, $A$, for \variable{a}. In $A$ the variable \variable{a} holds the value
$25$, and this is returned. Then the $B$-scope is searched for the \variable{b}-variable, and the value
$5$ is returned. The two integers are added, and the final return-value of the lambda-expression
ends up being $30$.

\subsection{Let-expressions}

\productname{} only supports \emph{single assignment}. Single assignment is not assignment
in the traditional imperative sense, but rather a way of binding a value to a symbol in a
certain scope. This is done using \emph{let-expressions}. Using a let-expression creates a
new scope in which the declared variables are accessible. When leaving the scope the
variables are destroyed.

The basic format of a let-expression is:

\texttt{let VARIABLE1 = EXPRESSION1 in EXPRESSION2}

In the example, the value of \texttt{EXPRESSION1} is assigned to \texttt{VARIABLE1}, which
is available in \texttt{EXPRESSION2}. Another example could be:

\texttt{let VARIABLE1 = EXPRESSION1, VARIABLE2 = EXPRESSION2 in EXPRESSION3}

In this example, the value of \texttt{EXPRESSION1} is assigned to \texttt{VARIABLE1}, and
the value of \texttt{EXPRESSION2} is assigned to \texttt{VARIABLE2}. Both \texttt{VARIABLE1}
and \texttt{VARIABLE2} are available in \texttt{EXPRESSION3} and only in \texttt{EXPRESSION3}.

Destructive assignments are not possible \productname{}, meaning that it isn't possible to 
reassign a variable. It is however possible to hide a variable.
Consider the following expression:

\codesample{lethiding.garry}

The value of this expression is $13$. This is because within the \texttt{\variable{x} + 2}-expression
the \variable{x}-variable evaluates to $6$. But in the outer expression \variable{x} evaluates to
$5$.

Nested \emph{let}-scopes are possible. Consider for instance:

\codesample{nestedlet.garry}

In the inner scope, both \variable{x} and \variable{y} are available. This is of course equivalent
to:

\codesample{nestedlet2.garry}


