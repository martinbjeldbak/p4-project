\section{Grammar}
\label{sec:grammar}

\subsection{Notational Conventions}
We use a variant of Extended Backus-Naur Form to express the context-free grammar of
our programming language.

Each production rule assigns an expression of terminals, non-terminals and operations
to a non-terminal. E.g. in the following example the non-terminal $decimal$ is assigned
the possible terminals of $\gter{0}$ up to and including $\gter{9}$.

\begin{ebnf}
\grule{decimal}{\gter{0} \gor \gter{1} \gor \grange \gor \gter{9}}
\end{ebnf}

The following operations are used throughout this section:
\begin{center}
\begin{tabular}{r l}
  $\gopt{pattern}$ & an optional pattern \\
  $\grep{pattern}$ & zero or more repititions of pattern \\
  $\ggrp{pattern}$ & a group \\
  $pattern_1 \gor pattern_2$ & a selection \\
  $\gter{0} \gor \grange \gor \gter{9}$ & a range of terminals \\
  $pattern_1 \gex pattern_2$ & matched by $pattern_1$ but not by $pattern_2$\\
  $pattern_1 \gcat pattern_2$ & concatenation of $pattern_1$ and $pattern_2$ \\
  $\gter{test}$ & a terminal \\
  $\gtsq$ & a terminal single quotation mark \\
  $\gtdq$ & a terminal double quotation mark \\
  $\gtbs$ & a terminal backslash character \\
\end{tabular}
\end{center}


\subsection{Character Classes}
\begin{ebnf}
\grule{decimal}{\gter{0} \gor \gter{1} \gor \grange \gor \gter{9}}
\grule{lowercase}{\gter{a} \gor \gter{b} \gor \grange \gor \gter{z}}
\grule{uppercase}{\gter{A} \gor \gter{B} \gor \grange \gor \gter{Z}}
\grule{anycase}{lowercase \gor uppercase}
\grule{quotebs}{\gtdq \gor \gtbs}
\grule{unichar}{\gcomment{any unicode character}}
\grule{strchar}{unichar \gex quotebs}
\end{ebnf}
\subsection{Reserved Tokens}
\begin{ebnf}
%reserved
\grule{keyword}{\gter{game} \gor \gter{piece} \gor \gter{this} \gor \gter{width} \gor \gter{height}}
\galt{\gter{title} \gor \gter{players} \gor \gter{turnOrder} \gor \gter{board}}
\galt{\gter{grid} \gor \gter{setup} \gor \gter{wall} \gor \gter{name} \gor \gter{possibleDrops}}
\galt{\gter{possibleMoves} \gor \gter{winCondition} \gor \gter{tieCondition}}
\grule{shared\_operator}{\gter{*} \gor \gter{+}}
\grule{normal\_operator}{\gter{-} \gor \gter{!=} \gor \gter{==} \gor \gter{<=} \gor \gter{>=}}
\grule{pattern\_operator}{\gter{!} \gor \gter{?}}
\grule{pattern\_not}{\gter{!}}
\grule{pattern\_or}{\gter{|}}
\grule{pattern\_keyword}{\gter{friend} \gor \gter{foe} \gor \gter{this} \gor \gter{empty}}
\end{ebnf}
\subsection{Literals}
\begin{ebnf}
%Literals
\grule{integer}{deimal \gcat \grep{decimal}}
\grule{direction}{\gter{n} \gor \gter{s} \gor \gter{e} \gor \gter{w} \gor \gter{ne} \gor \gter{nw}}
\galt{\gter{se} \gor \gter{sw}}
\grule{coordinate}{upperccase \gcat \grep{uppercase} \gcat decimal \gcat \grep{decimal}}
\grule{string}{\gtdq \gcat \grep{strchar \gor \gtbs \gcat unichar} \gcat \gtdq}
\end{ebnf}
\subsection{Identifiers}
\begin{ebnf}
%Identifiers
\grule{function}{lowercase \gcat anycase \gcat \grep{anycase}}
\grule{identifier}{uppercase \gcat \grep{anycase}}
\grule{variable}{\gter{\$} \gcat anycase \gcat \grep{anycase}}
\end{ebnf}
\subsection{Program Structure}
\begin{ebnf}
%Program structure
\grule{program}{\grep{function\_def} \gcat game\_decl}
\grule{function\_def}{\gter{define} \gcat function \gcat \gter{[} \gcat \grep{variable} \gcat \gter{]} \gcat expression}
\grule{game\_decl}{\gter{game} \gcat declaration\_struct}
\grule{declaration\_struct}{\gter{\{} \gcat declaration \gcat \grep{declaration} \gter{\}}}
\grule{declaration}{\ggrp{keyword \gor identifier} \gcat structure}
\grule{structure}{declaration\_struct \gor expression}
\end{ebnf}
\subsection{Expressions}
\begin{ebnf}
%Expressions
\grule{expression}{function\_call}
\galt{element \gcat operator \gcat expression}
\galt{assignment}
\galt{if\_expr}
\galt{lambda\_expr}
\galt{element}
\galt{\gter{not} \gcat expression}
\grule{element}{\gter{(} \gcat expression \gcat \gter{)}}
\galt{variable}
\galt{list}
\galt{\gter{/} \gcat pattern \gcat \gter{/}}
\galt{keyword}
\galt{direction}
\galt{coordinate}
\galt{integer}
\galt{string}
\galt{identifier}
\galt{function}
\grule{function\_call}{function \gcat list}
\grule{assignment}{\gter{let} \gcat var \gcat \gter{=} \gcat expression \gcat \grep{\gter{,} \gcat variable \gcat \gter{=} \gcat expression} \gcat \gter{in} \gcat expression}
\grule{if\_expr}{\gter{if} \gcat expression \gcat \gter{then} \gcat expression \gcat \gter{else} \gcat expression}
\grule{lambda\_expr}{\gter{\#} \gcat \gter{[} \gcat \grep{variable} \gcat \gter{]} \gcat \gter{=>} \gcat expression}
\grule{list}{\gter{[} \gcat \grep{element} \gcat \gter{]}}
\end{ebnf}
\subsection{Patterns}
\begin{ebnf}
%Patterns
\grule{pattern}{pattern\_expr \gcat \grep{pattern\_expr}}
\grule{pattern\_expr}{pattern\_val \gcat \gopt{\gter{*} \gor \gter{?} \gor \gter{+}}}
\galt{pattern\_val \gcat \gter{|} \gcat pattern\_expr}
\grule{pattern\_val}{direction}
\galt{variable}
\galt{pattern\_check}
\galt{\gter{!} \gcat pattern\_check}
\galt{\gter{(} \gcat pattern \gcat \gter{)} \gcat \gopt{integer}}
\grule{pattern\_check}{\gter{friend}}
\galt{\gter{foe}}
\galt{\gter{empty}}
\galt{\gter{this}}
\galt{identifier}
\end{ebnf}
