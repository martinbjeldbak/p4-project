\section{Definitions}
\label{sec:definitions}
In this section we present how programs written in \productname{} can be
structured with definitions og constant, types and abstract types.

We begin by presenting what a program can consist of and then we further specify
how these different definitions are built. We present constant definitions
followed by type definitions. We provide big-step semantics for type definitions
in \secref{sec:typedefinitions}.

\subsection{Program structure}

The outermost layer of a \productname{} program is a list of definitions:

\begin{ebnf}
\grule{program}{\grep{definition}}
\grule{definition}{constant\_def}
\galt{type\_def}
\end{ebnf}

A definition is either a constant definition or a type definition. So, when a
program has been run, we are left with a symbol table full of types and
constants.

As the above grammar shows, an empty program is valid in \productname{}, because
it is possible to have zero, one, or more definitions in the outermost layer of
the structuring og programs.

\subsection{Constant definitions}
\label{sec:constantdefinitions}

Functions are also constants and are defined with the the following definition:

\begin{ebnf}
\grule{constant\_def}{\gter{define} \gcat constant \gcat \gopt{varlist} \gcat
\gter{=} \gcat \gcat expression}
\end{ebnf}

A definition of a constants can contain a list of variables as the following
grammar rule:

\begin{ebnf}
\grule{varlist}{\gter{[} \gcat \gopt{variable \gcat \grep{\gter{,} \gcat
variable} \gcat \gopt{\gter{,} \gcat vars} \gor vars} \gcat \gter{]}}
\grule{vars}{\gter{...} \gcat variable}  
\end{ebnf}

A user can define custom constants for use in e.g. the implementation of a board game.
This is done using the $\gter{define}$-keyword. Functions can be declared to accept
any number of parameters or none at all. An example of a function definition could
be:

\codesample{functiondef.garry}

It can be used as a way of putting frequently used expressions in one definition
of a constants and call that specific definition when it is needed instead of
writing (or pasting) the code every time it is needed. 

\productname{} supports variadic functions, which means that it is possible to define
functions with indefinite arity.

\todo{Example of indefinite arity (vars)}

\subsubsection{Scope rules for functions and constants}

Consider a function definition such as:

\codesample{functiondef.garry}

The variables \variable{a} and \variable{b} only exist within the function \function{max}.
When calling the function:

\codesample{functioncall.garry}

A new scope will be created and the values $5$ and $23$
are assigned to \variable{a} and \variable{b}, respectively.

\subsection{Type definitions}
\label{sec:typedefinitions}

The following grammar rules present how defining a type is done followed by the
associated definitions which can be used within a type definition. Types are
similar to what we normally call classes in object-oriented programming
languages. We wish to call them types in \productname{}.

\begin{ebnf}
\grule{type\_def}{\gter{type} \gcat type \gcat varlist \gcat
\gopt{\gter{extends} \gcat type \gcat list} \gopt{type\_body}}
\grule{type\_body}{\gter{\{} \gcat \grep{member\_def} \gcat \gter{\}}}
\grule{member\_def}{abstract\_def}
\galt{constant\_def}
\galt{data\_def}
\grule{abstract\_def}{\gter{define} \gcat \gter{abstract} \gcat constant \gcat
\gopt{varlist}} \grule{data\_def}{\gter{data} \gcat variable \gcat \gter{=}
\gcat expression}
\end{ebnf}

The keyword $\gter{type}$ is not the same as the identifier $type$, which was
presented in \secref{sec:identifiers}. All definitions of types must begin with
the keyword followed by the identifier.

\todo{Niels: Instantiering af superklassen.}

It is optional to include a body for a type, wherein further definitions can be
defined. These definitions must be encircled with a beginning and an ending brace. 

When defining an abstract constant it must be overridden before it can be used.
This is done by simply redefining the constant exactly as it was defined in the
definition of the abstract (with variables and such). So, a constants definition
with the same $constant$ and $varlist$ as an abstract constant, will override
the abstract constant.

\todo{Niels: Forklar data-begrebet.}
\subsubsection{Inheritance}

\productname{} supports single inheritance between types. An inheriting type, will
inherit all the members of its super type(s) (if \type{C} extends \type{B}, which
extends \type{A}, then \type{C} inherits all members from both \type{B} and \type{A}).
This also introduces the \keyword{super}-keyword, which can be used to access members
in superclasses. The following example shows how inheritance works:

\codesample{typescope2.junta}

\productname{} doesn't have an \keyword{abstract}-keyword for type definitions, only
for constant/function definitions. A type is implicitly marked as abstract if it has
unimplemented abstract members. In the above example the type \type{A} is abstract,
since because it's member, \constant{constantA}, is abstract. Likewise, the type
\type{B} is abstract because it extends \type{A}, but doesn't implement the abstract
member of \type{A}. The type \type{C} on the other hand is not abstract, since it
implements the abstract constant. Abstract types can't be constructed, albeit the
constructor for an abstract type has to be used when extending the type (after the
\keyword{extends}-keyword).


\subsubsection{Big-step semantics}

The semantics presented in \tableref{semantic:typedef} are the transition rules for type definitions.
These type definitions have some optional arguments which correspond with the
written grammar for these definitions, and this is why there are four transition
rules described.

\begin{table}[ht]
    \begin{tabular*}{\textwidth}{l l}
      \hline \\
      \hspace{0.4cm} $\left[\mbox{TYPEDEF}\right]$ & \infrule{env_{C} \vdash
      \lag D_{G}, env_{T}[T \mapsto \left(T, X, \varepsilon, \varepsilon,
      \varepsilon \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T\; X\; D_{G},\; env_{T} \rag \ra
      env_{T}'} \\

      \hspace{0.4cm} $\left[\mbox{TYPEDEF}_{\mbox{BODY}}\right]$ &
      \infrule{env_{C} \vdash \lag D_{G}, env_{T}[T \mapsto \left(T, X, D_{M},
      \varepsilon, \varepsilon \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T\; X\; \left\{D_{M}\right\}\;
      D_{G},\; env_{T} \rag \ra env_{T}'} \\

      \hspace{0.4cm} $\left[\mbox{TYPEDEF}_{\mbox{EXTEND}}\right]$ &
      \infrule{env_{C} \vdash \lag D_{G}, env_{T}[T_{1} \mapsto \left(T_{1}, X,
      \varepsilon, L, T_{2} \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T_{1}\; X\; \texttt{extends}\;
      T_{2}\; L\; D_{G},\; env_{T} \rag \ra env_{T}'} \\

      \hspace{0.4cm} $\left[\mbox{TYPEDEF}_{\mbox{EXTEND-BODY}}\right]$ &
      \infrule{env_{C} \vdash \lag D_{G}, env_{T}[T_{1} \mapsto \left(T_{1}, X,
      D_{M}, L, T_{2} \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T_{1}\; X\; \texttt{extends}\;
      T_{2}\; L\; \left\{D_{M}\right\}\; D_{G},\; env_{T} \rag \ra env_{T}'} \\
      \hline \\
    \end{tabular*}
    \capt{Transition rules for type definitions.}
    \label{semantic:typedef}
\end{table}

In the premises of the rules we present a 5-tuple where $env_{T}$ is updated
according to the rule. In three of the four 5-tuples we include the symbol
$\varepsilon$, which denotes that the given position of the symbol is an empty
slot. This is again due to the fact that we have some optional arguments.

The 5-tuple is ordered as follows:

\begin{nlist}
\item $\mathbf{T_{k}}$ - current type
  \item $\mathbf{X}$ - current type's formal parameters
  \item $\mathbf{D_{M}}$ - member definitions
  \item $\mathbf{L}$ - super type's parameters
  \item $\mathbf{T_{k+1}}$ - super type
\end{nlist}

Throughout the transition rules we use the 5-tuple to update the type environment.
