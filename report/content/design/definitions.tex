\section{Definitions}
\label{sec:definitions}
In this section we present how programs written in \productname{} can be
structured with definitions of constants and types.

We begin by presenting what a program can consist of and then we further specify
how these different definitions are built. We present constant definitions
followed by type definitions. We provide big-step semantics for type definitions
in \secref{sec:typedefinitions}.

\subsection{Program structure}

The outermost layer of a \productname{} program is a list of definitions:

\begin{ebnf}
\grule{program}{\grep{definition}}
\grule{definition}{constant\_def}
\galt{type\_def}
\end{ebnf}

A definition is either a constant definition or a type definition. So, when a
program has been run, we are left with a symbol table full of types and
constants.

As the above grammar shows, an empty program is valid in \productname{}, because
it is possible to have zero, one, or more definitions in the outermost layer of
the structuring of programs.

\subsection{Constant definitions}
\label{sec:constantdefinitions}

Functions are also constants and are defined with the following definition:

\begin{ebnf}
\grule{constant\_def}{\gter{define} \gcat constant \gcat \gopt{varlist} \gcat
\gter{=} \gcat \gcat expression}
\end{ebnf}

A function definition needs a list of formal parameters, formal parameters (a
$varlist$) are described with the following grammar:

\begin{ebnf}
\grule{varlist}{\gter{[} \gcat \gopt{variable \gcat \grep{\gter{,} \gcat
variable} \gcat \gopt{\gter{,} \gcat vars} \gor vars} \gcat \gter{]}}
\grule{vars}{\gter{...} \gcat variable}  
\end{ebnf}

Creating constants and functions outside of type definitions adds them to the
global scope, meaning that they are essentially accessible from anywhere in the
program (provided that they are not hidden by a constant within a type).

An example of a global function is the following implementation of function for
computing the greatest of two numbers:

\codesample{functiondef.garry}

Essentially this creates a constant in the global scope named \constant{max},
which when used, returns a value of type \type{Function}. Since function values
can also be created with lambda expressions (as described in
\secref{sec:lambdaexpressions}), the following constant definition is equivalent
to \csref{functiondef.garry}:

\codesample{functiondef.junta}

This equivalence only holds for global constants, since type constants/methods
are a bit more special as described in \secref{sec:typedefinitions}.

Constants and functions are useful for putting frequently used expressions or
values in one place.

The non-terminal $vars$ is used for variadic functions, another feature of
\productname{}. Variadic functions are functions with indefinite arity, meaning
they will accept any number of actual parameters. In \productname{} this is
supported for both lambda expressions and functions. The following code sample
is an example of two variadic functions:


\subsubsection{Scope rules for functions and constants}

Consider a function definition such as:

\codesample{functiondef.garry}

The variables \variable{a} and \variable{b} only exist within the function \function{max}.
When calling the function:

\codesample{functioncall.garry}

A new scope will be created and the values $5$ and $23$
are assigned to \variable{a} and \variable{b}, respectively.

\subsection{Type definitions}
\label{sec:typedefinitions}

The following grammar rules present how defining a type is done followed by the
associated definitions which can be used within a type definition. Types are
similar to what we normally call classes in object-oriented programming
languages. We wish to call them types in \productname{}.

\begin{ebnf}
\grule{type\_def}{\gter{type} \gcat type \gcat varlist \gcat
\gopt{\gter{extends} \gcat type \gcat list} \gopt{type\_body}}
\grule{type\_body}{\gter{\{} \gcat \grep{member\_def} \gcat \gter{\}}}
\grule{member\_def}{abstract\_def}
\galt{constant\_def}
\galt{data\_def}
\grule{abstract\_def}{\gter{define} \gcat \gter{abstract} \gcat constant \gcat
\gopt{varlist}} \grule{data\_def}{\gter{data} \gcat variable \gcat \gter{=}
\gcat expression}
\end{ebnf}

The keyword $\gter{type}$ is not the same as the identifier $type$, which was
presented in \secref{sec:identifiers}. All definitions of types must begin with
the keyword followed by the identifier.

\todo{Niels: Instantiering af superklassen.}

It is optional to include a body for a type, wherein further definitions can be
defined. These definitions must be encircled with a beginning and an ending brace. 

When defining an abstract constant it must be overridden before it can be used.
This is done by simply redefining the constant exactly as it was defined in the
definition of the abstract (with variables and such). So, a constants definition
with the same $constant$ and $varlist$ as an abstract constant, will override
the abstract constant.

\todo{Niels: Forklar data-begrebet.}
\subsubsection{Inheritance}

\todo{repeating stuff from introduction}

\productname{} supports single inheritance between types. An inheriting type, will
inherit all the members of its super type(s) (if \type{C} extends \type{B}, which
extends \type{A}, then \type{C} inherits all members from both \type{B} and \type{A}).
This also introduces the \keyword{super}-keyword, which can be used to access members
in superclasses. The following example shows how inheritance works:

\codesample{typescope2.junta}

\productname{} doesn't have an \keyword{abstract}-keyword for type definitions, only
for constant/function definitions. A type is implicitly marked as abstract if it has
unimplemented abstract members. In the above example the type \type{A} is abstract,
since because it's member, \constant{constantA}, is abstract. Likewise, the type
\type{B} is abstract because it extends \type{A}, but doesn't implement the abstract
member of \type{A}. The type \type{C} on the other hand is not abstract, since it
implements the abstract constant. Abstract types can't be constructed, albeit the
constructor for an abstract type has to be used when extending the type (after the
\keyword{extends}-keyword).


\subsubsection{Big-step semantics}

The semantics presented in \tableref{semantic:typedef} are the transition rules for type definitions.
These type definitions have some optional arguments which correspond with the
written grammar for these definitions, and this is why there are four transition
rules described.

\begin{table}[ht]
    \begin{tabular*}{\textwidth}{l l}
      \hline \\
      \hspace{0.4cm} $\left[\mbox{TYPEDEF}\right]$ & \infrule{env_{C} \vdash
      \lag D_{G}, env_{T}[T \mapsto \left(T, X, \varepsilon, \varepsilon,
      \varepsilon \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T\; X\; D_{G},\; env_{T} \rag \ra
      env_{T}'} \\

      \hspace{0.4cm} $\left[\mbox{TYPEDEF}_{\mbox{BODY}}\right]$ &
      \infrule{env_{C} \vdash \lag D_{G}, env_{T}[T \mapsto \left(T, X, D_{M},
      \varepsilon, \varepsilon \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T\; X\; \left\{D_{M}\right\}\;
      D_{G},\; env_{T} \rag \ra env_{T}'} \\

      \hspace{0.4cm} $\left[\mbox{TYPEDEF}_{\mbox{EXTEND}}\right]$ &
      \infrule{env_{C} \vdash \lag D_{G}, env_{T}[T_{1} \mapsto \left(T_{1}, X,
      \varepsilon, L, T_{2} \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T_{1}\; X\; \texttt{extends}\;
      T_{2}\; L\; D_{G},\; env_{T} \rag \ra env_{T}'} \\

      \hspace{0.4cm} $\left[\mbox{TYPEDEF}_{\mbox{EXTEND-BODY}}\right]$ &
      \infrule{env_{C} \vdash \lag D_{G}, env_{T}[T_{1} \mapsto \left(T_{1}, X,
      D_{M}, L, T_{2} \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T_{1}\; X\; \texttt{extends}\;
      T_{2}\; L\; \left\{D_{M}\right\}\; D_{G},\; env_{T} \rag \ra env_{T}'} \\
      \hline \\
    \end{tabular*}
    \capt{Transition rules for type definitions.}
    \label{semantic:typedef}
\end{table}

In the premises of the rules we present a 5-tuple where $env_{T}$ is updated
according to the rule. In three of the four 5-tuples we include the symbol
$\varepsilon$, which denotes that the given position of the symbol is an empty
slot. This is again due to the fact that we have some optional arguments.

The 5-tuple is ordered as follows:

\begin{nlist}
\item $\mathbf{T_{k}}$ - current type
  \item $\mathbf{X}$ - current type's formal parameters
  \item $\mathbf{D_{M}}$ - member definitions
  \item $\mathbf{L}$ - super type's parameters
  \item $\mathbf{T_{k+1}}$ - super type
\end{nlist}

Throughout the transition rules we use the 5-tuple to update the type environment.
