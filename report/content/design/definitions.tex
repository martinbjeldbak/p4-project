\section{Definitions}
\label{sec:definitions}
In this section we present how programs written in \productname{} can be
structured with definitions of constants and types.

We begin by presenting what a program can consist of and then we further specify
how these different definitions are built. We present constant definitions
followed by type definitions. We provide big-step semantics for type definitions
in \secref{sec:typedefinitions}.

\subsection{Program structure}

The outermost layer of a \productname{} program is a list of definitions:

\begin{ebnf}
\grule{program}{\grep{definition}}
\grule{definition}{constant\_def}
\galt{type\_def}
\end{ebnf}

A definition is either a constant definition or a type definition. So, when a
program has been run, we are left with a symbol table full of types and
constants.

As the above grammar shows, an empty program is valid in \productname{}, because
it is possible to have zero, one, or more definitions in the outermost layer of
the structuring of programs.

\subsection{Constant definitions}
\label{sec:constantdefinitions}

Functions are also constants and are defined with the following definition:

\begin{ebnf}
\grule{constant\_def}{\gter{define} \gcat constant \gcat \gopt{varlist} \gcat
\gter{=} \gcat \gcat expression}
\end{ebnf}

A function definition needs a list of formal parameters, formal parameters (a
$varlist$) are described with the following grammar:

\begin{ebnf}
\grule{varlist}{\gter{[} \gcat \gopt{variable \gcat \grep{\gter{,} \gcat
variable} \gcat \gopt{\gter{,} \gcat vars} \gor vars} \gcat \gter{]}}
\grule{vars}{\gter{...} \gcat variable}  
\end{ebnf}

Creating constants and functions outside of type definitions adds them to the
global scope, meaning that they are essentially accessible from anywhere in the
program (provided that they are not hidden by a constant within a type).

An example of a global function is the following implementation of function for
computing the greatest of two numbers:

\codesample{functiondef.garry}

Essentially this creates a constant in the global scope named \constant{max},
which when used, returns a value of type \type{Function}. Since function values
can also be created with lambda expressions (as described in
\secref{sec:lambdaexpressions}), the following constant definition is equivalent
to \csref{functiondef.garry}:

\codesample{functiondef.junta}

This equivalence only holds for global constants, since type constants/methods
are a bit more special as described in \secref{sec:typedefinitions}.

Constants and functions are useful for putting frequently used expressions or
values in one place.

The non-terminal $vars$ is used for variadic functions, another feature of
\productname{}. Variadic functions are functions with indefinite arity, meaning
they will accept any number of actual parameters. In \productname{} this is
supported for both lambda expressions and functions. The following code sample
is an example of two variadic functions:

\codesample{variadic.junta}

The use of the \texttt{"..."}-terminal marks that the following variable
represents a list that holds all additional parameters passed to the function.
In the above example, calling the function \constant{last} with no parameters,
is possible and results in the formal parameter \variable{args} holding the
value of an empty list, \texttt{[]}. Additionally, \constant{last} can be called
with any number of parameters, which will then be appended to the list in
\variable{args}. In the second function, \constant{myMap}, at least one
actual parameter must be provided (since the variadic parameter is the second
one). But other than that, the parameter passing works in the same way as with
\constant{last}, in that the function accepts any number of parameters greater
than or equal to $1$. Some uses and result of the two functions are shown in the
following two examples:

\codesample{variadicuse2.junta}
\codesample{variadicuse1.junta}

One limit is that the variadic parameter (the one after \texttt{"..."}) must be
the last one in the list of formal parameters, and there can only be one. This
is expressed in the grammar.

\subsubsection{Scope rules for functions and constants}

Consider the \constant{max}-function in \csref{functiondef.garry}. Its formal
parameters \variable{a} and \variable{b} only exist, and are only available
within the \constant{max}-function. The following example shows a call of the
\constant{max}-function:

\codesample{functioncall.garry}

When called with the actual parameters $5$ and $23$, a new scope is created and
the actual parameters are assigned to the formal parameters \variable{a} and
\variable{b}, respectively. The body of the function (the if expression) is then
evaluated and the result is returned. When returning, the variables
\variable{a} and \variable{b} cease to exist. 

\subsection{Type definitions}
\label{sec:typedefinitions}

As described the introduction of this chapter, types are a central part of
\productname{} and being able to define custom user types is essential when
creating board games.
The following grammar rules present how type definitions work in
\productname{} followed by the associated definitions which can be used within
a type definition.

\begin{ebnf}
\grule{type\_def}{\gter{type} \gcat type \gcat varlist \gcat
\gopt{\gter{extends} \gcat type \gcat list} \gopt{type\_body}}
\grule{type\_body}{\gter{\{} \gcat \grep{member\_def} \gcat \gter{\}}}
\grule{member\_def}{abstract\_def}
\galt{constant\_def}
\galt{data\_def}
\grule{abstract\_def}{\gter{define} \gcat \gter{abstract} \gcat constant \gcat
\gopt{varlist}} \grule{data\_def}{\gter{data} \gcat variable \gcat \gter{=}
\gcat expression}
\end{ebnf}

The simplest type that can be created is a type such as:

\codesample{simplesttype.junta}

The type \type{A} is a type without any data, constructor parameters, constants
or parent type. This type is truly useless, since it has no identity or
behaviour. It can however be instantiated, and instances of it can be compared
using the \texttt{==}, \texttt{!=}, and \texttt{is}-operators. But since the
type has no identity in any way, all instances will be equal:

\codesample{simplesttypeuse.junta}

\subsubsection{The constructor}

One way to add identity to objects, is with the constructor. In the previous
example of a very simple type, the constructor takes no parameters (the empty
parameter list \texttt{[]} after the type name). If we were to add some formal
parameters to the type definition, it could look like:

\codesample{typedef1.junta}

Now in order to instantiate \type{A}, we must provide the constructor with two
parameters: 

\codesample{typedef1use.junta}

Notice how in the first line, the two objects are equal to each other, while in
the second line they are not. This means that we have successfully added
identity to the \type{A}-type.

\subsubsection{The constants}

Constants within types are defined in the same way as constants outside of
types. The difference is that constants defined within a type can only be
accessed within that type (and inheriting types) or by using the dot-notation
outside of the type.

\codesample{typedef2.junta}

In the example above, two constants are defined within type \type{A};
\constant{b} and \constant{calculate}. The first one \constant{b} is a simple
constant holding the value of \variable{b}, the constructor parameter, plus one.
It can be seen as a getter, since it makes the value of \variable{b} visible to
the outside. \constant{calculate} is a method that returns the sum of some
numbers. In order to call the constants contained within a type, we use the dot
notation on an object of that type:

\codesample{typedef2use.junta}

The variable \variable{obj} is assigned an instance of the \type{A}-type. Using
the dot-notation, the method \constant{calculate} is called on the object.

\subsubsection{The data}

Another way to add identity to objects, is to add data fields to the type.
Unlike constants, data fields contain private semi-mutable data. In the
strictest sense, the data is still immutable, but using the
\keyword{set}-keyword, it is possible to clone the current object, and return a
new one with the selected data fields set to new values. The following example
shows a new version of type \type{A}, with a data field:

\codesample{typedef3.junta}

In this example, we define the data field \variable{att} with the default value
of $15$. Since data fields are not accessible from outside of the type, we must
define a getter, the constant \constant{att}, in order to make the value
visible. Using the \keyword{set}-keyword, we can also define at setter, the
\constant{setAtt}-method, which returns a new instance of \type{A} with
\variable{att} set to whatever parameter \constant{setAtt} was called with.

The following example show the use of this setter, to create a clone of an
instance of \type{A}:

\codesample{typedef3use.junta}

This time, we create an instance of \type{A}, and then calls \constant{setAtt}
on that instance, in order to get a new instance of \type{A} with \variable{att}
set to $2$. After that, the values are accessed using the getter. Note that,
again, the two objects are not equal, since the value of \variable{obj2} is
different than \variable{obj1}.

\subsubsection{Inheritance}

\todo{repeating stuff from introduction}

\productname{} supports single inheritance between types. An inheriting type, will
inherit all the members of its super type(s) (if \type{C} extends \type{B}, which
extends \type{A}, then \type{C} inherits all members from both \type{B} and \type{A}).
This also introduces the \keyword{super}-keyword, which can be used to access members
in superclasses. The following example shows how inheritance works:

\codesample{typescope2.junta}

\productname{} doesn't have an \keyword{abstract}-keyword for type definitions, only
for constant/function definitions. A type is implicitly marked as abstract if it has
unimplemented abstract members. In the above example the type \type{A} is abstract,
since because it's member, \constant{constantA}, is abstract. Likewise, the type
\type{B} is abstract because it extends \type{A}, but doesn't implement the abstract
member of \type{A}. The type \type{C} on the other hand is not abstract, since it
implements the abstract constant. Abstract types can't be constructed, albeit the
constructor for an abstract type has to be used when extending the type (after the
\keyword{extends}-keyword).

\subsubsection{Big-step semantics}

The semantics presented in \tableref{semantic:typedef} are the transition rules for type definitions.
These type definitions have some optional arguments which correspond with the
written grammar for these definitions, and this is why there are four transition
rules described.

\begin{table}[ht]
    \begin{tabular*}{\textwidth}{l l}
      \hline \\
      \hspace{0.4cm} $\left[\mbox{TYPEDEF}\right]$ & \infrule{env_{C} \vdash
      \lag D_{G}, env_{T}[T \mapsto \left(T, X, \varepsilon, \varepsilon,
      \varepsilon \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T\; X\; D_{G},\; env_{T} \rag \ra
      env_{T}'} \\

      \hspace{0.4cm} $\left[\mbox{TYPEDEF}_{\mbox{BODY}}\right]$ &
      \infrule{env_{C} \vdash \lag D_{G}, env_{T}[T \mapsto \left(T, X, D_{M},
      \varepsilon, \varepsilon \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T\; X\; \left\{D_{M}\right\}\;
      D_{G},\; env_{T} \rag \ra env_{T}'} \\

      \hspace{0.4cm} $\left[\mbox{TYPEDEF}_{\mbox{EXTEND}}\right]$ &
      \infrule{env_{C} \vdash \lag D_{G}, env_{T}[T_{1} \mapsto \left(T_{1}, X,
      \varepsilon, L, T_{2} \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T_{1}\; X\; \texttt{extends}\;
      T_{2}\; L\; D_{G},\; env_{T} \rag \ra env_{T}'} \\

      \hspace{0.4cm} $\left[\mbox{TYPEDEF}_{\mbox{EXTEND-BODY}}\right]$ &
      \infrule{env_{C} \vdash \lag D_{G}, env_{T}[T_{1} \mapsto \left(T_{1}, X,
      D_{M}, L, T_{2} \right)] \rag \ra env_{T}'}
      {env_{C} \vdash \lag \texttt{type}\; T_{1}\; X\; \texttt{extends}\;
      T_{2}\; L\; \left\{D_{M}\right\}\; D_{G},\; env_{T} \rag \ra env_{T}'} \\
      \hline \\
    \end{tabular*}
    \capt{Transition rules for type definitions.}
    \label{semantic:typedef}
\end{table}

In the premises of the rules we present a 5-tuple where $env_{T}$ is updated
according to the rule. In three of the four 5-tuples we include the symbol
$\varepsilon$, which denotes that the given position of the symbol is an empty
slot. This is again due to the fact that we have some optional arguments.

The 5-tuple is ordered as follows:

\begin{nlist}
\item $\mathbf{T_{k}}$ - current type
  \item $\mathbf{X}$ - current type's formal parameters
  \item $\mathbf{D_{M}}$ - member definitions
  \item $\mathbf{L}$ - super type's parameters
  \item $\mathbf{T_{k+1}}$ - super type
\end{nlist}

Throughout the transition rules we use the 5-tuple to update the type environment.
